<?xml version="1.0" ?>
<!DOCTYPE pmc-articleset PUBLIC "-//NLM//DTD ARTICLE SET 2.0//EN" "https://dtd.nlm.nih.gov/ncbi/pmc/articleset/nlm-articleset-2.0.dtd">
<pmc-articleset><article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article">
  <?properties open_access?>
  <front>
    <journal-meta>
      <journal-id journal-id-type="nlm-ta">Springerplus</journal-id>
      <journal-id journal-id-type="iso-abbrev">Springerplus</journal-id>
      <journal-title-group>
        <journal-title>SpringerPlus</journal-title>
      </journal-title-group>
      <issn pub-type="epub">2193-1801</issn>
      <publisher>
        <publisher-name>Springer International Publishing</publisher-name>
        <publisher-loc>Cham</publisher-loc>
      </publisher>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="pmid">27350905</article-id>
      <article-id pub-id-type="pmc">4899405</article-id>
      <article-id pub-id-type="publisher-id">2251</article-id>
      <article-id pub-id-type="doi">10.1186/s40064-016-2251-0</article-id>
      <article-categories>
        <subj-group subj-group-type="heading">
          <subject>Research</subject>
        </subj-group>
      </article-categories>
      <title-group>
        <article-title>A distributed query execution engine of big attributed graphs</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <name>
            <surname>Batarfi</surname>
            <given-names>Omar</given-names>
          </name>
          <address>
            <email>obatarfi@kau.edu.sa</email>
          </address>
          <xref ref-type="aff" rid="Aff1"/>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Elshawi</surname>
            <given-names>Radwa</given-names>
          </name>
          <address>
            <email>ambarnawi@kau.edu.sa</email>
          </address>
          <xref ref-type="aff" rid="Aff2"/>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Fayoumi</surname>
            <given-names>Ayman</given-names>
          </name>
          <address>
            <email>afayoumi@kau.edu.sa</email>
          </address>
          <xref ref-type="aff" rid="Aff1"/>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Barnawi</surname>
            <given-names>Ahmed</given-names>
          </name>
          <address>
            <email>rmelshawi@pnu.edu.sa</email>
          </address>
          <xref ref-type="aff" rid="Aff1"/>
        </contrib>
        <contrib contrib-type="author" corresp="yes">
          <name>
            <surname>Sakr</surname>
            <given-names>Sherif</given-names>
          </name>
          <address>
            <email>ssakr@cse.unsw.edu.au</email>
          </address>
          <xref ref-type="aff" rid="Aff3"/>
          <xref ref-type="aff" rid="Aff4"/>
        </contrib>
        <aff id="Aff1"><label/>King Abdulaziz University, Jeddah, Saudi Arabia </aff>
        <aff id="Aff2"><label/>Princess Nourah Bint Abdulrahman University, Riyadh, Saudi Arabia </aff>
        <aff id="Aff3"><label/>University of New South Wales, Sydney, Australia </aff>
        <aff id="Aff4"><label/>King Saud bin Abdulaziz University for Health Sciences, Riyadh, Saudi Arabia </aff>
      </contrib-group>
      <pub-date pub-type="epub">
        <day>23</day>
        <month>5</month>
        <year>2016</year>
      </pub-date>
      <pub-date pub-type="pmc-release">
        <day>23</day>
        <month>5</month>
        <year>2016</year>
      </pub-date>
      <pub-date pub-type="collection">
        <year>2016</year>
      </pub-date>
      <volume>5</volume>
      <issue>1</issue>
      <elocation-id>665</elocation-id>
      <history>
        <date date-type="received">
          <day>15</day>
          <month>1</month>
          <year>2016</year>
        </date>
        <date date-type="accepted">
          <day>27</day>
          <month>4</month>
          <year>2016</year>
        </date>
      </history>
      <permissions>
        <copyright-statement>&#xA9; The Author(s). 2016</copyright-statement>
        <license license-type="OpenAccess">
          <license-p>
<bold>Open Access</bold>This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made.</license-p>
        </license>
      </permissions>
      <abstract id="Abs1">
        <p>A graph is a popular data model that has become pervasively used for modeling structural relationships between objects. In practice, in many real-world graphs, the graph vertices and edges need to be associated with descriptive attributes. Such type of graphs are referred to as <italic>attributed graphs</italic>. G-SPARQL has been proposed as an expressive language, with a <italic>centralized</italic> execution engine, for querying attributed graphs. G-SPARQL supports various types of graph querying operations including reachability, pattern matching and shortest path where any G-SPARQL query may include value-based predicates on the descriptive information (attributes) of the graph edges/vertices in addition to the structural predicates. In general, a main limitation of centralized systems is that their vertical scalability is always restricted by the physical limits of computer systems. This article describes the design, implementation in addition to the performance evaluation of <italic>DG-SPARQL</italic>, a <italic>distributed</italic>, hybrid and adaptive parallel execution engine of G-SPARQL queries. In this engine, the topology of the graph is distributed over the main memory of the underlying nodes while the graph data are maintained in a relational store which is replicated on the disk of each of the underlying nodes. DG-SPARQL evaluates parts of the query plan via SQL queries which are pushed to the underlying relational stores while other parts of the query plan, as necessary, are evaluated via indexless memory-based graph traversal algorithms. Our experimental evaluation shows the efficiency and the scalability of DG-SPARQL on querying massive attributed graph datasets in addition to its ability to outperform the performance of Apache Giraph, a popular distributed graph processing system, by orders of magnitudes.</p>
      </abstract>
      <funding-group>
        <award-group>
          <funding-source>
            <institution-wrap>
              <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/501100004919</institution-id>
              <institution>King Abdulaziz City for Science and Technology</institution>
            </institution-wrap>
          </funding-source>
          <award-id>11-INF1990-03</award-id>
          <principal-award-recipient>
            <name>
              <surname>Batarfi</surname>
              <given-names>Omar</given-names>
            </name>
          </principal-award-recipient>
        </award-group>
      </funding-group>
      <custom-meta-group>
        <custom-meta>
          <meta-name>issue-copyright-statement</meta-name>
          <meta-value>&#xA9; The Author(s) 2016</meta-value>
        </custom-meta>
      </custom-meta-group>
    </article-meta>
  </front>
  <body>
    <sec id="Sec1">
      <title>Introduction</title>
      <p>In this era, we are witness continuous expansion and integration of computation, networking, digital devices and data storage systems in a way that provided a rich platform for the explosion in big data as well as the means by which big data are produced, stored, processed and analyzed. In practice, there exist various modern big data applications where data are intuitively and naturally modeled as big graphs including social networks, spatial road networks, protein interaction networks, neural networks and the Internet of Things&#xA0;(Faloutsos et&#xA0;al. <xref ref-type="bibr" rid="CR13">1999</xref>; Kleinberg et&#xA0;al. <xref ref-type="bibr" rid="CR30">1999</xref>). For example, Facebook reported that, during the first quarter of 2015, it had an average of 1.44 billions monthly active users.<xref ref-type="fn" rid="Fn1">1</xref> Therefore, it has become very crucial for several applications to have the ability of efficiently store, query and analyze these big graphs&#xA0;(Sakr and Pardede <xref ref-type="bibr" rid="CR52">2011</xref>).</p>
      <p>Attributed graph&#xA0;(Ehrig et&#xA0;al. <xref ref-type="bibr" rid="CR12">2004</xref>) is a variant graph data model where each node<xref ref-type="fn" rid="Fn2">2</xref> is identified with a unique identifier and labeled with a string. Each edge in the attributed graph is also identified with a unique identifier and labeled with a string. In addition, each edge connects a source node to a destination node. In attributed graphs, each node or an edge can be associated with a collection of key/value pairs that represent its descriptive information or properties. Given a large attributed graph that includes billions of edges and nodes (e.g., bibliographic network, social network) with their descriptive information, one of the fundamental challenges is on how to efficiently query and analyze these big graphs.</p>
      <p>In practice, querying datasets which are represented using any kind of data models (e.g., Relational, XML, Graph) typically involves two main steps: query representation and formulation using a query language (e.g., SQL for relational model, XPath for XML) and efficient evaluation of the formulated queries using a querying execution engine. Although SQL is a popular and standard query language for the relational model, it is not adequate for graph querying purposes as it requires users to reason in terms of tables and join operations between them instead of the intuitive reasoning of graph as a group of vertices and edges that link them. Therefore, in the general context of the graph data model, a number of graph querying languages has been proposed such as: PQL&#xA0;(Leser <xref ref-type="bibr" rid="CR34">2005</xref>), GraphQL&#xA0;(He and Singh <xref ref-type="bibr" rid="CR24">2008</xref>), SPARQL&#xA0;(Prud&#x2019;hommeaux and Seaborne <xref ref-type="bibr" rid="CR41">2008</xref>) and Cypher&#xA0;(<xref ref-type="bibr" rid="CR11">2015</xref>). G-SPARQL&#xA0;(Sakr et&#xA0;al. <xref ref-type="bibr" rid="CR51">2012</xref>) has been proposed as an expressive language with design focus on querying attributed graphs. The language supports the formulation of various kinds of graph querying operations including reachability, shortest path and pattern matching queries. In G-SPARQL, each query may include value-based predicates on the attributes of the graph edges/vertices in addition to the structural predicates. Sakr et&#xA0;al. (<xref ref-type="bibr" rid="CR48">2014</xref>) presented a <italic>centralized</italic> execution engine for G-SPARQL queries which identifies parts of the query plan (sub-plans) to be evaluated using the underlying relational store via SQL queries while the evaluation of other sub-plans of the main query plan are executed via indexless main memory-based graph traversal algorithms. In general, one of the fundamental limitations of centralized systems is that their performance is bounded by the computing resources which can be allocated to a single machine. In addition, centralized systems can only be scaled vertically by adding more computing resources to the underlying machines. However, the vertical scalability of centralized systems is always restricted by the physical limits of computer systems. On the other hand, a distributed system represents a set of autonomous nodes, each with their computing resources (e.g., memory, disk), that cooperate to perform computations and exchange data as messages via a network. In practice, one of the main advantages of distributed data processing systems is that they can scale to nearly arbitrarily increasing data sizes by effectively leveraging horizontal scalability where additional computer resources (cooperating nodes) can be added easily.</p>
      <p>With the increasing size of big graph datasets and the growing needs and popularity of interactive querying systems over these graphs, it becomes crucial to manage large graphs in distributed environments that can support query execution with low latency. In this article, we present <italic>DG-SPARQL</italic>, short for <italic>D</italic>istributed <italic>G-SPARQL</italic>, a distributed query execution engine which takes the evaluation of G-SPARQL queries to the next level in terms of performance and scalability. In particular, DG-SPARQL is designed for handling large and distributed attributed graphs and overcoming many of the challenges and limitations of centralized query engines. In DG-SPARQL, the topology of the graph is distributed over the main memory of the underlying nodes while the graph data are maintained in a relational store which is replicated on the disk of each of the underlying nodes&#xA0;(Hammoud et&#xA0;al. <xref ref-type="bibr" rid="CR22">2015</xref>). Similar to the centralized implementation of G-SPARQL, DG-SPARQL evaluates parts of the query plan via SQL queries which are pushed to underlying RDBMS nodes while other parts of the query plan are evaluated via indexless main memory-based graph traversal algorithms, as needed. However, DG-SPARQL applies selectivity-based query processing that exploits the estimation of predicate selectivities to parallelize and optimize the query evaluation process using the divide-and-conquer strategy for generating the query plans. In particular, the number of used RDBMS nodes for each query varies and is determined based on a defined cost model. Thus, DG-SPARQL combines the advantages of the efficient data storage and query execution features of relational stores, the efficiency of main memory graph traversal operations in addition to the efficiency and scalability of distributed systems. The main contributions of this article can be summarized as follows:<list list-type="bullet"><list-item><p>We present the design and implementation of <italic>DG-SPARQL</italic>, a full-fledged distributed and parallel G-SPARQL query execution engine of big attributed graphs. In DG-SPARQL, the graph topology is loaded into the distributed main memory of the computing cluster while the graph data is replicated on a relational store at each node. In practice, providing scalable execution engines of expressive query languages for big attributed graphs expands the effectiveness of analyzing and understanding real world graphs and enriches the variance on the kinds of questions which could be answered via graph querying systems.</p></list-item><list-item><p>DG-SPARQL adopts a rule-based query optimizer to split the query plan among the main memory and relational components of the execution engines. In addition, it adaptively selects different numbers of the underlying relational nodes, for each query, for executing the SQL-based parts of the execution plan using selectivity estimation techniques and a cost model.</p></list-item><list-item><p>We demonstrate the efficiency and scalability of DG-SPARQL via an extensive set of experiments that use big synthetic and real graph datasets in addition to a comparison with Apache Giraph, a popular distributed graph processing system.</p></list-item></list>The remainder of this article is organized as follows. Background information about attributed graphs and G-SPARQL query language are provided in &#x201C;<xref rid="Sec2" ref-type="sec">Background</xref>&#x201D; section. Details of the distributed hybrid representation of DG-SPARQL for the attributed graphs are presented in &#x201C;<xref rid="Sec5" ref-type="sec">Distributed hybrid representation of the attributed
graphs</xref>&#x201D; section while the details of the distributed query execution engine are presented in &#xA0;&#x201C;<xref rid="Sec6" ref-type="sec">Distributed query execution engine</xref>&#x201D; section. The results of our performance evaluation are presented in &#x201C;<xref rid="Sec9" ref-type="sec">Experimental evaluation</xref>&#x201D; section. The related work on graph querying systems is reviewed in &#x201C;<xref rid="Sec16" ref-type="sec">Related work</xref>&#x201D; section before we finally conclude the article in &#x201C;<xref rid="Sec17" ref-type="sec">Conclusion</xref>&#x201D; section.</p>
    </sec>
    <sec id="Sec2">
      <title>Background</title>
      <p>Herewith, we introduce the main concepts that form the groundwork for our presented system: attributed graph and the G-SPARQL query language.</p>
      <sec id="Sec3">
        <title>Attributed graphs</title>
        <p>In many real applications, it is of high practical value that the graph edges and nodes get associated with descriptive information (attributes) in the form of key-value pairs. This type of graphs are referred to as <italic>attributed graphs</italic>. Formally, an <italic>attributed graph</italic> is denoted as (<inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$N, E, L_n, L_e, F_n, F_e, \Gamma _n, \Gamma _e$$\end{document}</tex-math><mml:math id="M2"><mml:mrow><mml:mi>N</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="normal">&#x393;</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="normal">&#x393;</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq1.gif"/></alternatives></inline-formula>) where:<list list-type="bullet"><list-item><p><italic>N</italic> defines the set of graph nodes that represent the application objects.</p></list-item><list-item><p><inline-formula id="IEq2"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$E \subseteq N \times N$$\end{document}</tex-math><mml:math id="M4"><mml:mrow><mml:mi>E</mml:mi><mml:mo>&#x2286;</mml:mo><mml:mi>N</mml:mi><mml:mo>&#xD7;</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq2.gif"/></alternatives></inline-formula> defines the set of edges joining two graph nodes and represent the structural relationships between the application objects.</p></list-item><list-item><p><inline-formula id="IEq3"><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$L_n$$\end{document}</tex-math><mml:math id="M6"><mml:msub><mml:mi>L</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq3.gif"/></alternatives></inline-formula> is the set of labels for the graph nodes.</p></list-item><list-item><p><inline-formula id="IEq4"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$L_e$$\end{document}</tex-math><mml:math id="M8"><mml:msub><mml:mi>L</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq4.gif"/></alternatives></inline-formula> is the set of labels for the graph edges.</p></list-item><list-item><p><inline-formula id="IEq5"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$F_n$$\end{document}</tex-math><mml:math id="M10"><mml:msub><mml:mi>F</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq5.gif"/></alternatives></inline-formula> is a function <inline-formula id="IEq6"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$N \rightarrow L_n$$\end{document}</tex-math><mml:math id="M12"><mml:mrow><mml:mi>N</mml:mi><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq6.gif"/></alternatives></inline-formula> that associates labels with the graph nodes.</p></list-item><list-item><p><inline-formula id="IEq7"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$F_e$$\end{document}</tex-math><mml:math id="M14"><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq7.gif"/></alternatives></inline-formula> is a function <inline-formula id="IEq8"><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$E \rightarrow L_e$$\end{document}</tex-math><mml:math id="M16"><mml:mrow><mml:mi>E</mml:mi><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq8.gif"/></alternatives></inline-formula> that associates labels with the graph edges.</p></list-item><list-item><p><inline-formula id="IEq9"><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Gamma _n =\{a_1, a_2,\ldots , a_x\}$$\end{document}</tex-math><mml:math id="M18"><mml:mrow><mml:msub><mml:mi mathvariant="normal">&#x393;</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x2026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq9.gif"/></alternatives></inline-formula> is a set of <italic>x</italic> attributes that can be associated with any graph node <inline-formula id="IEq10"><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$(n) \in N$$\end{document}</tex-math><mml:math id="M20"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x2208;</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq10.gif"/></alternatives></inline-formula>. In particular, each node <inline-formula id="IEq11"><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$n \in N$$\end{document}</tex-math><mml:math id="M22"><mml:mrow><mml:mi>n</mml:mi><mml:mo>&#x2208;</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq11.gif"/></alternatives></inline-formula> can be associated with a vector of key/value pairs <inline-formula id="IEq12"><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$[a_1(v_1),\ldots , a_m(v_m)]$$\end{document}</tex-math><mml:math id="M24"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>&#x2026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq12.gif"/></alternatives></inline-formula> where <inline-formula id="IEq13"><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$a_j(v_j)$$\end{document}</tex-math><mml:math id="M26"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq13.gif"/></alternatives></inline-formula> represents the attribute value of node <italic>n</italic> on attribute <inline-formula id="IEq14"><alternatives><tex-math id="M27">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$a_j$$\end{document}</tex-math><mml:math id="M28"><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq14.gif"/></alternatives></inline-formula>.</p></list-item><list-item><p><inline-formula id="IEq15"><alternatives><tex-math id="M29">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Gamma _e =\{b_1, b_2,\ldots , b_y\}$$\end{document}</tex-math><mml:math id="M30"><mml:mrow><mml:msub><mml:mi mathvariant="normal">&#x393;</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x2026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq15.gif"/></alternatives></inline-formula> is a set of <italic>y</italic> attributes that can be associated with any edge <inline-formula id="IEq16"><alternatives><tex-math id="M31">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$(e) \in E$$\end{document}</tex-math><mml:math id="M32"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x2208;</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq16.gif"/></alternatives></inline-formula>. In particular, each edge <inline-formula id="IEq17"><alternatives><tex-math id="M33">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$e \in E$$\end{document}</tex-math><mml:math id="M34"><mml:mrow><mml:mi>e</mml:mi><mml:mo>&#x2208;</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq17.gif"/></alternatives></inline-formula> can be associated with a vector of key/value pairs <inline-formula id="IEq18"><alternatives><tex-math id="M35">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$[b_1(e_1),\ldots , b_n(e_u)]$$\end{document}</tex-math><mml:math id="M36"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>&#x2026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq18.gif"/></alternatives></inline-formula> where <inline-formula id="IEq19"><alternatives><tex-math id="M37">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$b_k(e_k)$$\end{document}</tex-math><mml:math id="M38"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq19.gif"/></alternatives></inline-formula> represents the attribute value of edge <italic>e</italic> on attribute <inline-formula id="IEq20"><alternatives><tex-math id="M39">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$b_k$$\end{document}</tex-math><mml:math id="M40"><mml:msub><mml:mi>b</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq20.gif"/></alternatives></inline-formula>.</p></list-item></list><fig id="Fig1"><label>Fig. 1</label><caption><p>A sample attributed graph for bibliographic network</p></caption><graphic xlink:href="40064_2016_2251_Fig1_HTML" id="MO1"/></fig></p>
        <p>Figure <xref rid="Fig1" ref-type="fig">1</xref> illustrates an example of a snippet of an attributed graph of a bibliographic network where each node represents an object instance (e.g. <italic>article</italic>, <italic>author</italic>, <italic>scientific journal</italic>, <italic>affiliation</italic>) and each edge represents a structural relationship (e.g. <italic>supervise</italic>, <italic>friend_Of</italic>, <italic>author</italic>, <italic>affiliated_At</italic>, <italic>published_In</italic>) between two graph nodes. Additionally, the various types of graph nodes are described with different attributes (e.g. <italic>type</italic>, <italic>keyword</italic>, <italic>publisher</italic>, <italic>volume</italic>, <italic>country</italic>), denoted with solid rectangles, while another set of attributes (e.g. <italic>title</italic>, <italic>order</italic>, <italic>year</italic>), denoted with dashed rectangles, are used to describe their associated graph edges.</p>
        <p>In the general context of large graphs, there are popular kinds of graph querying operations including <italic>reachability queries</italic> that check the existence of a path between two nodes in the large graph, <italic>shortest path queries</italic> that returns the path, if it exists, with the smallest number of hops between any two nodes in the large graph and <italic>pattern matching queries</italic> that look for the occurrence(s) of a pattern-based subgraph in the large graph. In practice, in the context of large attributed graphs, it is common for many users to have the need to formulate queries that involve more than one of these graph querying operations. In addition, they commonly need to express filtering conditions (predicates) on the associated descriptive information (attributes) of the graph edges/nodes. Using the sample attributed graph of the bibliographic network illustrated in Fig.&#xA0;<xref rid="Fig1" ref-type="fig">1</xref>, samples of such queries are:<list list-type="order"><list-item><p>(SQ1): <italic>Structural pattern matching query with filtering conditions on the values of the attributes of the graph edges and nodes</italic>.</p><p>Search for the names of two authors, A and B, where AsupervisesB, both of A and B are affiliated_At UNSW, the age of B is greater than 25, the title of A at UNSW is &#x2019;Professor&#x2019; and B joined UNSW after 2010.</p></list-item><list-item><p>(SQ2): <italic>Structural reachability query with filtering conditions on the values of the attributes of the graph edges and nodes</italic>.</p><p>Search for the names of two authors, A and B, who are connected with a path which is less than or equal 4 steps (edges) where the age of A is greater than 25 and the age of B is greater than 35.</p></list-item><list-item><p>(SQ3): <italic>Structural reachability query combined with structural pattern matching in addition to filtering conditions on the values of the attributes of the graph edges and nodes</italic>.</p><p>Search for the names of two authors, A and B, who are connected via a sequence of edges (path) which is less than or equal 3 steps (edges) where the age of A is greater than 25, the age of B is greater than 35, A is affiliated_At KAU with title of Assistant Professor and Y joined UNSW after 2010.</p></list-item><list-item><p>(SQ4): <italic>Structural pattern matching query combined with structural reachability query with filtering conditions on the attributes of the edges of the retrieved path by the reachability query</italic>.</p><p>Search for the names of two authors, A and B, who are connected via a sequence of edges (path) which is less than or equal 3 steps (edges) where the age of A is greater than 25, the age of B is greater than 35 and no one of the authors in the connecting path between A and B has the tile of PhD student.</p></list-item></list></p>
      </sec>
      <sec id="Sec4">
        <title>G-SPARQL query language</title>
        <p>The first step on querying any kind of data is to formulate the user queries using an adequate expressive query language. The SPARQL query language has been recognized as the official W3C language for querying RDF graphs&#xA0;(Prud&#x2019;hommeaux and Seaborne <xref ref-type="bibr" rid="CR41">2008</xref>). In general, there are some fundamental differences between the attributed graph model and the RDF data model. For instance, the RDF data model uses graph edges to model both of the attribute/value pairs of the graph vertices, similar to the way of modeling the structural relationship with the other graph vertices. In addition, while the attributed graph considers edges as a first class citizen that can be directly associated with descriptive attributes, the RDF data model does not directly support associating the graph edges by descriptive attributes. However, a <italic>reification</italic> mechanism can be used to indirectly achieve this goal by relying on a nesting mechanism, auxiliary nodes. In practice, this mechanism is commonly referred to as &#x201C;<italic>The RDF Big Ugly</italic>&#x201D;&#xA0;(Powers <xref ref-type="bibr" rid="CR40">2003</xref>) as it can dramatically increase the graph size and consequently affects the query processing time. In addition, this solution is much less intuitive when it comes to the user on expressing his queries. Furthermore, some graph query operations which are of popular interest in the domain of large attributed graphs (e.g., <italic>shortest path</italic>) are not often considered as the main attention within the context of the RDF data model.<fig id="Fig2"><label>Fig. 2</label><caption><p>The grammar of <italic>G-SPARQL</italic> language&#xA0;(Sakr et&#xA0;al. <xref ref-type="bibr" rid="CR51">2012</xref>)</p></caption><graphic xlink:href="40064_2016_2251_Fig2_HTML" id="MO2"/></fig></p>
        <p><italic>G-SPARQL</italic>&#xA0;(Sakr et&#xA0;al. <xref ref-type="bibr" rid="CR51">2012</xref>) has been introduced as a concise extension of the SPARQL query language which is mainly focusing on addressing the user requirements for querying large attributed graphs. In principle, one of the main design decisions of the G-SPARQL query language is to keep the required extensions, on SPARQL, for the purpose of querying property graphs minimum. As a result, the space and complexity of issuing a query using DG-SPARQL is very similar to the SPARQL language. An additional advantage of this design decision is that the learning curve for G-SPARQL should be minimum for any user who is familiar with the SPARQL language. In particular, G-SPARQL relies the fundamental graph matching facility of the SPARQL language. however, it introduces language constructs for defining predicates on the values of the attributes of the graph edges or nodes that are specified in the query pattern. G-SPARQL also provide language constructs that support various and rich forms of querying graph paths (sequence of edges) that facilitates the formulation of shortest path queries and reachability queries between the graph nodes (e.g., graph edge traversals with filters on the values of the edge attributes). Furthermore, G-SPARQL enables expressing filtering predicates on the queried path patterns.</p>
        <p>The grammar of the <italic>G-SPARQL</italic> language is illustrated in Fig.&#xA0;<xref rid="Fig2" ref-type="fig">2</xref>. For the full details on the syntax and semantics of <italic>G-SPARQL</italic>, the readers are referred to&#xA0;Sakr et&#xA0;al. (<xref ref-type="bibr" rid="CR51">2012</xref>). In the following we show the G-SPARQL code examples that formulate the sample queries on the attributed graph of &#x201C;<xref rid="Sec3" ref-type="sec">Attributed graphs</xref>&#x201D; section. We start by illustrating the following G-SPARQL query syntax which formulates the semantics of the example query (SQ1) in &#x201C;<xref rid="Sec3" ref-type="sec">Attributed graphs</xref>&#x201D; section.</p>
        <graphic position="anchor" xlink:href="40064_2016_2251_Figa_HTML" id="MO3"/>
        <p>In this example, Line 3 formulates the structural supervise relationship between the the two target authors. The query triples in Lines 4 and 5 ensure that both authors are connected with a graph edge that represents the affiliated_At relationship with UNSW. Lines 6 and 9 represent a filtering condition on the age attribute of the graph node which represents the author B. Line 7 represents a boolean predicate on the title attribute of the graph edge which represents the affiliated_At relationship of author A. Lines 8 and 10 represent a filtering condition on the Year attribute of the graph edge which represents the affiliated_At relationship of author B.</p>
        <p>The formulation of the semantics of the example query (SQ2) in &#x201C;<xref rid="Sec3" ref-type="sec">Attributed graphs</xref>&#x201D; section is represented with the following G-SPARQL query syntax.</p>
        <graphic position="anchor" xlink:href="40064_2016_2251_Figb_HTML" id="MO4"/>
        <p>In this example, Line 3 formulates a structural reachability query between the the target author nodes. Line 8 represents a filter condition on the reachability query to filter out any reachable paths with more than 4 steps (edges). Lines 4 and 6 represent a filtering condition on the age attribute of the graph node which represents the author A while lines 5 and 7 represent a filtering condition on the age attribute of the author B.</p>
        <p>Finally, the following G-SPARQL query syntax formulates the semantics of the example query (SQ3).</p>
        <graphic position="anchor" xlink:href="40064_2016_2251_Figc_HTML" id="MO5"/>
        <p>Line 3 formulates a structural reachability query between the the target author nodes with a filter condition on the reachability query to filter out any reachable paths with more than 3 steps (edges), Line 13. Line 4 represents a structural predicate the ensures that author A is connected with affiliated_At relationship to KAU, with boolean predicate on the title attribute of the graph edge, Line 9. Line 5 represents a structural predicate that ensures that author B is connected with the affiliated_At relationship to UNSW while Lines 6 and 12 formulate the filtering condition on the joined attribute of the graph edge which represents the affiliated_At relationship. Lines 7 and 10 formulate a filtering condition on the age attribute of the graph node which represents the author A while lines 8 and 11 represent a filtering condition on the age attribute of the author B.</p>
      </sec>
    </sec>
    <sec id="Sec5">
      <title>Distributed hybrid representation of the attributed graphs</title>
      <p>In general, over several decades, relational model and relational database management systems (RDBMSs) have been recognized as the most widely used technology for data-intensive storage and querying applications. RDBMSs are well-known for their ability to support very efficient query engines that make use of various efficient data indexing mechanisms in addition to advanced query optimization techniques (e.g. join ordering, cost-based query processing). Therefore, several techniques and systems have been utilizing the efficiency of the relational model and RDBMSs for storing and querying various more sophisticated data models including XML&#xA0;(Gou and Chirkova <xref ref-type="bibr" rid="CR17">2007</xref>; Grust et&#xA0;al. <xref ref-type="bibr" rid="CR20">2004</xref>), RDF&#xA0;(Sakr and Al-Naymat <xref ref-type="bibr" rid="CR46">2009</xref>) and graphs&#xA0;(Sakr <xref ref-type="bibr" rid="CR50">2009</xref>; Sakr and Al-Naymat <xref ref-type="bibr" rid="CR47">2010</xref>). On the other hand, relational databases have shown to be inefficient for querying operations that involves recursive access or looping for significant numbers of rows via performing various expensive join queries that may lead to considerably huge intermediate results. Therefore, in the context of the graph model, performing traversal operations over the vertices and edges of graph-structured data which are stored in relational database turns to be time-inefficient because of the extensive number of required join operations plus the very expensive I/O disk access cost. Hence, it becomes more efficient to utilize main memory-based techniques to perform graph querying operations that involves heavy traversals on the graph topology (i.e, nodes and edges).</p>
      <p>In our approach, we follow the hybrid Disk/Memory mechanism for managing attributed graphs which is presented by Sakr et&#xA0;al. (<xref ref-type="bibr" rid="CR51">2012</xref>). In this mechanism, the data of the graph are maintained in a relational store while the topology of the graph is loaded into the main memory via a native pointer-based data structure for the sake of performing efficient graph traversal operations. In particular, a fully decomposed storage model (DSM)&#xA0;(Abadi et&#xA0;al. <xref ref-type="bibr" rid="CR1">2007</xref>; Copeland et&#xA0;al. <xref ref-type="bibr" rid="CR10">1985</xref>) is employed to store the attributed graph where each node and edge in the graph is assigned a unique identifier then the attributed graph is modeled using <inline-formula id="IEq21"><alternatives><tex-math id="M41">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$M + N$$\end{document}</tex-math><mml:math id="M42"><mml:mrow><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq21.gif"/></alternatives></inline-formula> 2-column tables and <italic>P</italic> 3-columns tables where <italic>M</italic> represents the number of unique attributes of the graph nodes, <italic>N</italic> represents the number of unique attributes of the graph edges and <italic>P</italic> is the number of unique relationships that occur among the graph nodes. Each of the (<inline-formula id="IEq22"><alternatives><tex-math id="M43">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$M + N$$\end{document}</tex-math><mml:math id="M44"><mml:mrow><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq22.gif"/></alternatives></inline-formula>) 2-columns tables collects the values for one attribute where it stores the node identifier (in the <italic>M</italic> tables) or the edge identifier (in the <italic>N</italic> tables) on the first column while the second column (<italic>Value</italic>) maintains the value of the associated attribute. The <italic>P</italic> 3-columns tables maintain the information of the graph topology where each table collects the information of all graph edges that models a specific relationship. Specifically, in these tables, each row describes the information of a graph edge via 3 attributes: the edge identifier (<italic>eID</italic>), the identifier of the source node of the edge (<italic>sID</italic>) and the identifier of the destination node (<italic>dID</italic>).</p>
      <p>Figure&#xA0;<xref rid="Fig3" ref-type="fig">3</xref> illustrates the relational representation for the sample attributed graph of Fig.&#xA0;<xref rid="Fig1" ref-type="fig">1</xref> using the described fully decomposed storage model. In this figure, the table Node Label encodes <italic>all</italic> the graph nodes using their identifiers and labels. The 2-column tables with the white background <inline-formula id="IEq23"><alternatives><tex-math id="M45">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\{$$\end{document}</tex-math><mml:math id="M46"><mml:mo stretchy="false">{</mml:mo></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq23.gif"/></alternatives></inline-formula>age, keyword, type, publisher, ISBN, established, country<inline-formula id="IEq24"><alternatives><tex-math id="M47">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\}$$\end{document}</tex-math><mml:math id="M48"><mml:mo stretchy="false">}</mml:mo></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq24.gif"/></alternatives></inline-formula> encodes the key/value pairs of the attribute information of the graph nodes. The 3-column tables <inline-formula id="IEq25"><alternatives><tex-math id="M49">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\{$$\end{document}</tex-math><mml:math id="M50"><mml:mo stretchy="false">{</mml:mo></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq25.gif"/></alternatives></inline-formula>supervise, friend_Of, author, affiliated_at, published_In<inline-formula id="IEq26"><alternatives><tex-math id="M51">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\}$$\end{document}</tex-math><mml:math id="M52"><mml:mo stretchy="false">}</mml:mo></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq26.gif"/></alternatives></inline-formula> encodes the graph edges with the structural information of connecting the graph nodes. The 2-column tables with the dark background&#xA0;<inline-formula id="IEq27"><alternatives><tex-math id="M53">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\{$$\end{document}</tex-math><mml:math id="M54"><mml:mo stretchy="false">{</mml:mo></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq27.gif"/></alternatives></inline-formula>title, order, joined, year, volume, number, period<inline-formula id="IEq28"><alternatives><tex-math id="M55">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\}$$\end{document}</tex-math><mml:math id="M56"><mml:mo stretchy="false">}</mml:mo></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq28.gif"/></alternatives></inline-formula> encodes the attribute information of the graph edges. Each of these encoding tables is indexed on its ID column with the aim of enabling efficient merge join operations for retrieving attributes of the same node/edge. Additionally, for each encoding table, a partitioned B-tree index (Value, ID) is used with the aim of enabling efficient execution of the value-based predicates on the attributes of the graph vertices or edges&#xA0;(Graefe <xref ref-type="bibr" rid="CR18">2003</xref>). For the graph topology, a native pointer-based main memory encoding is used to represent the information of the <italic>P</italic> tables which maintain the structural information of the graph edges. In practice, the <italic>P</italic> tables encode the mandatory information for performing index-free traversal operations on the graph topology [e.g., depth-first search (DFS)&#xA0;(Korf <xref ref-type="bibr" rid="CR32">1985</xref>) or breadth-first search (BFS)&#xA0;(Zhou and Hansen <xref ref-type="bibr" rid="CR64">2006</xref>)].<fig id="Fig3"><label>Fig. 3</label><caption><p>DSM relational encoding of attributed graph of Fig. <xref rid="Fig1" ref-type="fig">1</xref>
</p></caption><graphic xlink:href="40064_2016_2251_Fig3_HTML" id="MO6"/></fig></p>
      <p>In general, there are two main options for realizing scalability for data storage and querying application in order to cope with increasing data size and applications workloads: (1) <italic>Vertical Scalability</italic>: This option is implemented via allocating a bigger machine with more computing resources (e.g., CPU, Disk, Main Memory). (2) <italic>Horizontal Scalability</italic>: This option is implemented by distributing/replicating the data across multiple machines. In practice, the option of vertical scalability has the main limitation that its scalability is always restricted by the physical limits of computer systems while the option of horizontal scalability is both extensible and flexible as it facilitates the ability to easily scale out by adding storage space or adding a new physical machine. Hammoud et&#xA0;al. (<xref ref-type="bibr" rid="CR22">2015</xref>) classified the data storage and query execution systems into four main paradigms, illustrated in Fig.&#xA0;<xref rid="Fig4" ref-type="fig">4</xref>, which are described as follows:<fig id="Fig4"><label>Fig. 4</label><caption><p>The four paradigms for building data storage and querying systems&#xA0;Hammoud et&#xA0;al. (<xref ref-type="bibr" rid="CR22">2015</xref>)</p></caption><graphic xlink:href="40064_2016_2251_Fig4_HTML" id="MO7"/></fig><list list-type="bullet"><list-item><p><bold>Paradigm-I</bold>: Which represents the fully centralized option where the whole dataset (<italic>D</italic>) is absolutely stored on a single node and the evaluation of the user query (<italic>Q</italic>) is fully executed on the same node.</p></list-item><list-item><p><bold>Paradigm-II</bold>: Where the dataset (<italic>D</italic>) is distributed into <italic>n</italic> partitions <inline-formula id="IEq29"><alternatives><tex-math id="M57">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\{d_1, d_2, \ldots , d_n\}$$\end{document}</tex-math><mml:math id="M58"><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x2026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq29.gif"/></alternatives></inline-formula> which are stored at <italic>n</italic> nodes while the evaluation of the user query (<italic>Q</italic>) is parallelized over the multiple partitions/nodes.</p></list-item><list-item><p><bold>Paradigm-III</bold>: Similar to Paradigm-II, the dataset (<italic>D</italic>) is distributed into <italic>n</italic> partitions <inline-formula id="IEq30"><alternatives><tex-math id="M59">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\{d_1, d_2, \ldots , d_n\}$$\end{document}</tex-math><mml:math id="M60"><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x2026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq30.gif"/></alternatives></inline-formula> which are stored at different nodes, however, in this paradigm, the user query (<italic>Q</italic>) is decomposed into <italic>m</italic> sub-queries <inline-formula id="IEq31"><alternatives><tex-math id="M61">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\{q_1, q_2, \ldots , q_m\}$$\end{document}</tex-math><mml:math id="M62"><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x2026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq31.gif"/></alternatives></inline-formula> where the evaluation of each sub-query <inline-formula id="IEq32"><alternatives><tex-math id="M63">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$q_x$$\end{document}</tex-math><mml:math id="M64"><mml:msub><mml:mi>q</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq32.gif"/></alternatives></inline-formula> is executed on one of the data partitions/nodes <inline-formula id="IEq33"><alternatives><tex-math id="M65">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$d_y$$\end{document}</tex-math><mml:math id="M66"><mml:msub><mml:mi>d</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq33.gif"/></alternatives></inline-formula>.</p></list-item><list-item><p><bold>Paradigm-IV</bold>: In this paradigm, the dataset (<italic>D</italic>) is fully replicates at <italic>n</italic> nodes <inline-formula id="IEq34"><alternatives><tex-math id="M67">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\{D_1, D_2, \ldots , D_n\}$$\end{document}</tex-math><mml:math id="M68"><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x2026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq34.gif"/></alternatives></inline-formula> while the user query (<italic>Q</italic>) is decomposed into <italic>m</italic> sub-queries <inline-formula id="IEq35"><alternatives><tex-math id="M69">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\{q_1, q_2, \ldots , q_m\}$$\end{document}</tex-math><mml:math id="M70"><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x2026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq35.gif"/></alternatives></inline-formula> where the evaluation of each sub-query <inline-formula id="IEq36"><alternatives><tex-math id="M71">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$q_x$$\end{document}</tex-math><mml:math id="M72"><mml:msub><mml:mi>q</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq36.gif"/></alternatives></inline-formula> is executed on one of the data replicas/nodes <inline-formula id="IEq37"><alternatives><tex-math id="M73">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$D_y$$\end{document}</tex-math><mml:math id="M74"><mml:msub><mml:mi>D</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq37.gif"/></alternatives></inline-formula>.</p></list-item></list>In principle, a main limitation on the <italic>centralized</italic> hybrid Disk/Memory representation, <italic>Paradigm-I</italic>, which has been proposed by Sakr et&#xA0;al. (<xref ref-type="bibr" rid="CR51">2012</xref>) is its assumption that the graph topology may always fit to reside in the main memory of a single machine. Due to the continuous growth on the size of the graph datasets, this assumption might not be valid in many cases. In practice, currently, a single machine with a modern disk can still fit to host any big graph dataset (i.e., a graph with billions of nodes and edges), however, this may lead to severe thrashing to main memory and frequent accesses to disk. Consequently, this will lead to inefficient performance for any graph querying operations in addition to limited scalability. Therefore, managing big attributed graphs on a single machine may be infeasible, especially when the machine&#x2019;s memory is dwarfed by the size of the graph topology&#xA0;(Hammoud et&#xA0;al. <xref ref-type="bibr" rid="CR22">2015</xref>). To overcome the limitations of centralized query engines, DG-SPARQL is designed as a distributed and scalable systems that takes the evaluation of G-SPARQL query to the next level. In particular, DG-SPARQL follows a variant strategy of <italic>Paradigm-IV</italic> where the attributed graph is encoded using the fully decomposition model, illustrated in Fig.&#xA0;<xref rid="Fig3" ref-type="fig">3</xref>, and fully replicated in a disk-based relational store across <italic>n</italic> nodes. In addition, the graph topology is partitioned across the main memory of the <italic>n</italic> nodes and encoded using a pointer-based representation. In DG-SPARQL, the user query (<italic>Q</italic>) is decomposed into <italic>m</italic> sub-queries <inline-formula id="IEq38"><alternatives><tex-math id="M75">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\{q_1, q_2, \ldots , q_m\}$$\end{document}</tex-math><mml:math id="M76"><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x2026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>q</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq38.gif"/></alternatives></inline-formula> where the evaluation of each sub-query <inline-formula id="IEq39"><alternatives><tex-math id="M77">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$q_x$$\end{document}</tex-math><mml:math id="M78"><mml:msub><mml:mi>q</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq39.gif"/></alternatives></inline-formula> either can be pushed inside the relational store, via SQL, on one of the data replicas/nodes <inline-formula id="IEq40"><alternatives><tex-math id="M79">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$D_y$$\end{document}</tex-math><mml:math id="M80"><mml:msub><mml:mi>D</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq40.gif"/></alternatives></inline-formula> or evaluated via indexless memory-based graph traversal algorithms across the partitioned graph topology on the <italic>n</italic> nodes according rule-based and cost-based query optimization mechanism. As a result, DG-SPARQL can leverage larger aggregate memory capacities and higher computational power for managing attributed graph. More details about the distributed query execution mechanism will be presented in &#x201C;<xref rid="Sec6" ref-type="sec">Distributed Query Execution Engine</xref>&#x201D; section.</p>
      <p>In practice, by loading only the graph topology on the main memory of the underlying cluster, we are able to achieve a significant decrease on the main memory usage by avoiding the need to load the attributes of the graph node/edges and their data values, which are maintained in the <inline-formula id="IEq41"><alternatives><tex-math id="M81">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$M + N$$\end{document}</tex-math><mml:math id="M82"><mml:mrow><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq41.gif"/></alternatives></inline-formula> attribute tables, into the main memory. This decrease in the memory usage enable greater scalability capabilities for managing bigger graphs on a defined memory size or reducing the number of the machines on the underlying computing cluster. In addition, this mechanism avoids building additional memory-based indices for the graph attributes that could be needed for improving the associated value-based query predicates and rely for such tasks on the well-designed optimization capacity of the underlying relational storage.</p>
    </sec>
    <sec id="Sec6">
      <title>Distributed query execution engine</title>
      <sec id="Sec7">
        <title>System architecture</title>
        <p>
          <fig id="Fig5">
            <label>Fig. 5</label>
            <caption>
              <p>The architecture of DG-SPARQL query execution engine</p>
            </caption>
            <graphic xlink:href="40064_2016_2251_Fig5_HTML" id="MO8"/>
          </fig>
        </p>
        <p>Figure&#xA0;<xref rid="Fig5" ref-type="fig">5</xref> illustrates the architecture of the DG-SPARQL query execution engine which follows the Master/Slave paradigm. In this architecture, one node is designated as the Master/Coordinator node which is responsible for query parsing, compilation, optimization and coordinating the query execution process. As described earlier, DG-SPARQL is designed to use multiple nodes/machines (slaves) to query big attributed graphs with topology structure information that can not be maintained in the main memory of a single node. In particular, let us assume that the DG-SPARQL underlying cluster contain <italic>n</italic> nodes. Then, the topology of the attributed graph is <italic>partitioned</italic> into <italic>n</italic> disjoint partitions where each partition (<inline-formula id="IEq42"><alternatives><tex-math id="M83">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${ {TP}}_i$$\end{document}</tex-math><mml:math id="M84"><mml:msub><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq42.gif"/></alternatives></inline-formula>) is maintained in the main memory of one of the slave nodes while the relational encoding of the attributed graph is <italic>replicated</italic> on the relational store for all the <italic>n</italic> slave nodes. In this scheme, the coordinator node maintains the graph statistics information which is used during the query the optimization process. In addition, it uses a directory service that maintains two mappings: a mapping for each vertex identifier to its assigned memory partition identifier (<inline-formula id="IEq43"><alternatives><tex-math id="M85">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${ {TP}}_i$$\end{document}</tex-math><mml:math id="M86"><mml:msub><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq43.gif"/></alternatives></inline-formula>) and a mapping for each edge identifier to its memory partition identifier (<inline-formula id="IEq44"><alternatives><tex-math id="M87">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${ {TP}}_i$$\end{document}</tex-math><mml:math id="M88"><mml:msub><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq44.gif"/></alternatives></inline-formula>) as well. In general, the main goal of any effective graph partitioning algorithm is to preserve locality in graph accesses consequently to reduce communication overhead between partitions/nodes during the query evaluation process. In general, graph partitioning is a challenging problem by itself&#xA0;(Hendrickson and Kolda <xref ref-type="bibr" rid="CR25">2000</xref>) which is out of the focus of this work. In particular, DG-SPARQL remains agnostic towards the various graph partitioning schemes and is designed to be able to incorporate any of them. For our current implementation and experimental evaluation (&#x201C;<xref rid="Sec9" ref-type="sec">Experimental evaluation</xref>&#x201D; section), we employed the METIS partitioner&#xA0;(METIS <xref ref-type="bibr" rid="CR36">2014</xref>). In practice, one of the advantages of the METIS partitioner is that it collocates the nearby vertices that are nearby to be collocated on the same partition/machine which reduces the communication cost of common graph traversal operations (e.g., BFS or DFS).</p>
        <p>G-SPARQL is a declarative query language. Thus, for any G-SPARQL query, there are always various possible execution plans to evaluate such query. G-SPARQL is equipped with a query optimizer that seeks to optimize the query execution time for any input query. In particular, among a wide space of alternative possible query plans for executing the user input query, the query optimizer employs a cost model to predict the time execution cost of each plan then selects the execution plan that with the minimum cost for actual execution. In order to achieve this goal, the query coordinator node maintains a set of graph statistics (e.g., structural indices, selectivity information of value-based predicates on the attributes of graph nodes and edges) which are utilized by the query optimizer to estimate the time execution cost of each possible query plan. In practice, the query optimizer starts by compiling the user input query (<italic>Q</italic>) into a logical query plan <inline-formula id="IEq45"><alternatives><tex-math id="M89">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{QP}$$\end{document}</tex-math><mml:math id="M90"><mml:mi mathvariant="italic">QP</mml:mi></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq45.gif"/></alternatives></inline-formula> using a defined set of G-SPARQL algebraic operators&#xA0;(Sakr et&#xA0;al. <xref ref-type="bibr" rid="CR51">2012</xref>). Using the statistical information and the cost model, the query optimizer compiles the logical query plan (<inline-formula id="IEq46"><alternatives><tex-math id="M91">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{QP}$$\end{document}</tex-math><mml:math id="M92"><mml:mi mathvariant="italic">QP</mml:mi></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq46.gif"/></alternatives></inline-formula>) into a set of sub-query physical query execution plans, <inline-formula id="IEq47"><alternatives><tex-math id="M93">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{QP} \rightarrow \{\textit{RQP}_1, \ldots , \textit{RQP}_x, \textit{MQP}_1,\ldots , \textit{MQP}_y\}$$\end{document}</tex-math><mml:math id="M94"><mml:mrow><mml:mi mathvariant="italic">QP</mml:mi><mml:mo stretchy="false">&#x2192;</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi mathvariant="italic">RQP</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x2026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="italic">RQP</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="italic">MQP</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x2026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="italic">MQP</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq47.gif"/></alternatives></inline-formula>, where each <inline-formula id="IEq48"><alternatives><tex-math id="M95">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{RQP}_i$$\end{document}</tex-math><mml:math id="M96"><mml:msub><mml:mi mathvariant="italic">RQP</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq48.gif"/></alternatives></inline-formula> refers to a relational-based sub-query plan which is to be evaluated by one of the relational store on the underlying <italic>n</italic> slave nodes via SQL queries, <italic>x</italic> refers to the number of relational-based sub-query plans which is less than or equal to the number of slave machines (<italic>n</italic>) and each <inline-formula id="IEq49"><alternatives><tex-math id="M97">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{MQP}_j$$\end{document}</tex-math><mml:math id="M98"><mml:msub><mml:mi mathvariant="italic">MQP</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq49.gif"/></alternatives></inline-formula> refers to a main memory query plan which is to be evaluated via graph traversal operations.</p>
        <p>DG-SPARQL is designed to evaluate the sub-query plans in a parallel fashion. In particular, DG-SPARQL parallelizes the evaluation of the <italic>x</italic> relational-based sub-query plans by assigning the evaluation of each plan <inline-formula id="IEq50"><alternatives><tex-math id="M99">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{RQP}_i$$\end{document}</tex-math><mml:math id="M100"><mml:msub><mml:mi mathvariant="italic">RQP</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq50.gif"/></alternatives></inline-formula> into a distinct relational store of the underlying slave nodes (<italic>n</italic>). In addition, DG-SPARQL parallelizes the evaluation of the main memory query plans by relying on Bulk Synchronous Parallel-based&#xA0;(Valiant <xref ref-type="bibr" rid="CR60">1990</xref>) graph traversal operations and communication over the graph partitions <inline-formula id="IEq51"><alternatives><tex-math id="M101">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$(TP_n)$$\end{document}</tex-math><mml:math id="M102"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:msub><mml:mi>P</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq51.gif"/></alternatives></inline-formula>. In the following subsection, we present the query optimization and execution details of the DG-SPARQL query engine.</p>
      </sec>
      <sec id="Sec8">
        <title>Query optimization and execution in DG-SPARQL</title>
        <p>In general, one of the powerful features of any declarative query language, like G-SPARQL, is that it provides its users with the ability to describe the logic of their querying operation without the need to get into the details of how such query will be executed. In particular, it becomes the responsibility of the query execution engine to enumerate the various possible query execution plans, for any user declarative query, and select among them one for actual execution. Ideally, the selected plan is the one with the lowest execution time. In practice, choosing such an optimal execution plan is not a trivial task. Therefore, DG-SPARQL relies on a set of cost-based query optimization techniques that attempt to estimate the cost of the various possible execution plans and predicts the one with the lowest-cost or at least a closest one to it. In order to achieve this goal, DG-SPARQL starts by compiling the user input query into a logical query plan using a defined set of G-SPARQL algebraic operators, listed in Table&#xA0;<xref rid="Tab1" ref-type="table">1</xref>&#xA0;(Sakr et&#xA0;al. <xref ref-type="bibr" rid="CR51">2012</xref>). In general, the G-SPARQL algebraic operators can be classified into two main groups:<list list-type="bullet"><list-item><p><italic>Retrieval-Based Operators</italic>: This group of operators (NgetAttVal, EgetAttVal, getEdgeNodes, strucPred, edgeJoin) is mainly used for retrieving a target set of the graph nodes and edges and can be intuitively represented by the standard relational operators (e.g., select, project, join)&#xA0;(Sakr et&#xA0;al. <xref ref-type="bibr" rid="CR51">2012</xref>).</p></list-item><list-item><p><italic>Traversal-Based Operators</italic>: This group of operators (pathJoin, sPathJoin, filterPath) is mainly evaluated via traversal operations over the graph topology and can not be intuitively represented by the standard relational operators.</p></list-item></list><table-wrap id="Tab1"><label>Table 1</label><caption><p>
<italic>G-SPARQL</italic> algebraic operators&#xA0;Sakr et&#xA0;al. (<xref ref-type="bibr" rid="CR51">2012</xref>)</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Operator</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">
NgetAttVal
</td><td align="left">Returns the values of an attribute for a set of nodes</td></tr><tr><td align="left">
EgetAttVal
</td><td align="left">Returns the values of an attribute for a set of edges</td></tr><tr><td align="left">
getEdgeNodes
</td><td align="left">Returns adjacent nodes, optionally through a specific relation, for a set of graph nodes</td></tr><tr><td align="left">
strucPred
</td><td align="left">Returns a set of vertices that are adjacent to other vertices with a specific relationship and optionally returns the connecting edges</td></tr><tr><td align="left">
edgeJoin
</td><td align="left">Returns pairs of vertices that are connected with an edge, optionally of a specified relationship, and optionally returns the connecting edges</td></tr><tr><td align="left">
pathJoin
</td><td align="left">Returns pairs of vertices which are connected by a sequence of edges of any length, optionally with a specified relationship, and optionally returns connecting paths</td></tr><tr><td align="left">
sPathJoin
</td><td align="left">Returns pairs of vertices which are connected by a sequence of edges of any length, optionally with a specified relationship, and returns the <italic>shortest</italic> connecting path</td></tr><tr><td align="left">
filterPath
</td><td align="left">Returns paths that satisfy a condition</td></tr></tbody></table></table-wrap></p>
        <p>After generating the initial logical plan of the input G-SPARQL query, this initial plan gets optimized using some common rules that include the traditional rules for relational algebraic optimization (e.g. pushing the selection operators down the plan) in addition to some rules that are specific to the context of the G-SPARQL query plans&#xA0;(Sakr et&#xA0;al. <xref ref-type="bibr" rid="CR48">2014</xref>). To illustrate, Fig. <xref rid="Fig6" ref-type="fig">6</xref> presents an example algebraic compilation for the following G-SPARQL query:</p>
        <graphic position="anchor" xlink:href="40064_2016_2251_Figd_HTML" id="MO9"/>
        <p>
          <fig id="Fig6">
            <label>Fig. 6</label>
            <caption>
              <p>An example DAG plan for G-SPARQL</p>
            </caption>
            <graphic xlink:href="40064_2016_2251_Fig6_HTML" id="MO10"/>
          </fig>
        </p>
        <p>As illustrated in Fig.&#xA0;<xref rid="Fig6" ref-type="fig">6</xref>, G-SPARQL logical plans are commonly organized in a DAG shape. In particular, the query planner traverses the logical query plan in a bottom-up fashion (starting by the leave nodes and then climbing the various paths of the query plan up to the root) and groups the connected neighbours retrieval-based operators into initial set of relational-based sub query plans (<italic>RQP</italic>). This climbing process for each path stops once it touches a traversal-based operator. For example, in Fig.&#xA0;<xref rid="Fig6" ref-type="fig">6</xref>, as indicated by dashed rectangles in the figure, two candidate relational-based sub-query plans, <inline-formula id="IEq52"><alternatives><tex-math id="M103">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{RQP}_1$$\end{document}</tex-math><mml:math id="M104"><mml:msub><mml:mi mathvariant="italic">RQP</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq52.gif"/></alternatives></inline-formula> and <inline-formula id="IEq53"><alternatives><tex-math id="M105">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{RQP}_2$$\end{document}</tex-math><mml:math id="M106"><mml:msub><mml:mi mathvariant="italic">RQP</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq53.gif"/></alternatives></inline-formula>, have been identified. In principle, the main strategy of DG-SPARQL query execution engine is to group the retrieval-based operators into relational-based sub-query plans (<italic>RQP</italic>) and parallelize their execution, via SQL queries, using the relational stores of the underlying nodes while each traversal-based operators represents a main memory query plan (<italic>MQP</italic>) which is evaluated using BSP-based traversals&#xA0;(Valiant <xref ref-type="bibr" rid="CR60">1990</xref>), synchronized by the coordinator node, over the partitioned graph topology. Using this mechanism, DG-SPARQL can rely on the underlying relational stores on finding the most efficient physical execution plan of its assigned sub-query plans, represented via SQL queries, by leveraging its built-in advanced and sophisticated query optimization mechanisms (e.g., join ordering, join implementation, index selection).</p>
        <p>To illustrate the performance advantage of DG-SPARQL as a distributed and parallel query execution engine, let us consider the illustrated query plan of Fig.&#xA0;<xref rid="Fig6" ref-type="fig">6</xref>. For such query plan, the query evaluation process using a centralized execution engine of G-SPARQL typically goes through a sequential execution of the following three main steps:<list list-type="order"><list-item><p>S1: The relational-based sub-query plan (<inline-formula id="IEq54"><alternatives><tex-math id="M107">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{RQP}_1$$\end{document}</tex-math><mml:math id="M108"><mml:msub><mml:mi mathvariant="italic">RQP</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq54.gif"/></alternatives></inline-formula>) gets translated into SQL query (<inline-formula id="IEq55"><alternatives><tex-math id="M109">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{SQL}_1$$\end{document}</tex-math><mml:math id="M110"><mml:msub><mml:mi mathvariant="italic">SQL</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq55.gif"/></alternatives></inline-formula>) which is pushed for evaluation inside the underlying relational store.</p></list-item><list-item><p>S2: The relational-based sub-query plan (<inline-formula id="IEq56"><alternatives><tex-math id="M111">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{RQP}_2$$\end{document}</tex-math><mml:math id="M112"><mml:msub><mml:mi mathvariant="italic">RQP</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq56.gif"/></alternatives></inline-formula>) gets translated into SQL query (<inline-formula id="IEq57"><alternatives><tex-math id="M113">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{SQL}_2$$\end{document}</tex-math><mml:math id="M114"><mml:msub><mml:mi mathvariant="italic">SQL</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq57.gif"/></alternatives></inline-formula>) which is pushed for evaluation inside the underlying relational store.</p></list-item><list-item><p>S2: The results, retrieved nodes, of (<inline-formula id="IEq58"><alternatives><tex-math id="M115">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{SQL}_1$$\end{document}</tex-math><mml:math id="M116"><mml:msub><mml:mi mathvariant="italic">SQL</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq58.gif"/></alternatives></inline-formula>) and (<inline-formula id="IEq59"><alternatives><tex-math id="M117">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{SQL}_2$$\end{document}</tex-math><mml:math id="M118"><mml:msub><mml:mi mathvariant="italic">SQL</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq59.gif"/></alternatives></inline-formula>) are then passed for further memory-based processing using the traversal-based operator, pathJoin, and the following operators in the query plan.</p></list-item></list>As a result, the total execution time for this execution plan in a centralized query engine (<italic>CentralizedT</italic>) is represented by the sum of the execution times of the three steps:<disp-formula id="Equ1"><alternatives><tex-math id="M119">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \textit{CentralizedT} = T(S1) + T(S2) + T(S3) \end{aligned}$$\end{document}</tex-math><mml:math id="M120" display="block"><mml:mrow><mml:mtable columnspacing="0.5ex"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi mathvariant="italic">CentralizedT</mml:mi><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="40064_2016_2251_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula>On the other hand, a simple intuitive alternative execution plan in the DG-SPARQL execution engine is to parallelize the execution of (<inline-formula id="IEq60"><alternatives><tex-math id="M121">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{SQL}_1$$\end{document}</tex-math><mml:math id="M122"><mml:msub><mml:mi mathvariant="italic">SQL</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq60.gif"/></alternatives></inline-formula>) and (<inline-formula id="IEq61"><alternatives><tex-math id="M123">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{SQL}_2$$\end{document}</tex-math><mml:math id="M124"><mml:msub><mml:mi mathvariant="italic">SQL</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq61.gif"/></alternatives></inline-formula>), representing the two steps S1 and S2, over the relational stores of two distinct slave machines, to retrieve the target graph vertices and edges, and then parallelize the execution of the pathJoin operator over the partitioned graph topology, (S3). Therefore, the total execution time for this parallelized execution plan in DG-SPARQL (<italic>DistributedT</italic>) can be represented as follows:<disp-formula id="Equ2"><alternatives><tex-math id="M125">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \textit{DistributedT} = Max\,(T(S1), T(S2)) + T(P(S3)) \end{aligned}$$\end{document}</tex-math><mml:math id="M126" display="block"><mml:mrow><mml:mtable columnspacing="0.5ex"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi mathvariant="italic">DistributedT</mml:mi><mml:mo>=</mml:mo><mml:mi>M</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi><mml:mspace width="0.166667em"/><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="40064_2016_2251_Article_Equ2.gif" position="anchor"/></alternatives></disp-formula>where (<italic>P</italic>(<italic>S</italic>3)) represents the BSP-based parallel implementation of (S3). Clearly, the parallel execution of G-SPARQL query plans using DG-SPARQL mechanism can show a significant reduction in the total execution time.</p>
        <p>In practice, in DG-SPARQL, the execution of each candidate relational-based sub query plan (<italic>RQP</italic>) can typically have various alternatives. For example, it can be translated into a single SQL query which is executed by a single relational store of the underlying nodes. Alternatively, it can be decomposed and translated into multiple SQL queries which are parallelly executed over multiple nodes. It is the job of the G-SPARQL query optimizer to enumerate the various possible decompositions (<inline-formula id="IEq62"><alternatives><tex-math id="M127">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$D_1,D_2,\ldots ,D_v$$\end{document}</tex-math><mml:math id="M128"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x2026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq62.gif"/></alternatives></inline-formula>) for the candidate relational-based query plan and chooses only one plan, which is predicated to have the lowest execution time, for actual execution. For example, let us assume a relational-based sub query plan (<inline-formula id="IEq63"><alternatives><tex-math id="M129">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{RQP}$$\end{document}</tex-math><mml:math id="M130"><mml:mi mathvariant="italic">RQP</mml:mi></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq63.gif"/></alternatives></inline-formula>) with a possible decomposition (<inline-formula id="IEq64"><alternatives><tex-math id="M131">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$D_i$$\end{document}</tex-math><mml:math id="M132"><mml:msub><mml:mi>D</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq64.gif"/></alternatives></inline-formula>) into the set of decomposed plans, <inline-formula id="IEq65"><alternatives><tex-math id="M133">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{RQP}\rightarrow \{\textit{DRQP}_1, \textit{DRQP}_2, \ldots , \textit{DRQP}_d\}$$\end{document}</tex-math><mml:math id="M134"><mml:mrow><mml:mi mathvariant="italic">RQP</mml:mi><mml:mo stretchy="false">&#x2192;</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi mathvariant="italic">DRQP</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="italic">DRQP</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x2026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="italic">DRQP</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq65.gif"/></alternatives></inline-formula>. The DG-SPARQL predicts the total execution time (<inline-formula id="IEq66"><alternatives><tex-math id="M135">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$TT(D_i)$$\end{document}</tex-math><mml:math id="M136"><mml:mrow><mml:mi>T</mml:mi><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq66.gif"/></alternatives></inline-formula>) of each possible decomposition by estimating the following components:<list list-type="bullet"><list-item><p><inline-formula id="IEq67"><alternatives><tex-math id="M137">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ET(\textit{DRQP}_x)$$\end{document}</tex-math><mml:math id="M138"><mml:mrow><mml:mi>E</mml:mi><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="italic">DRQP</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq67.gif"/></alternatives></inline-formula>: represents the estimated execution time for locally evaluating any decomposed plan, <inline-formula id="IEq68"><alternatives><tex-math id="M139">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{DRQP}_x$$\end{document}</tex-math><mml:math id="M140"><mml:msub><mml:mi mathvariant="italic">DRQP</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq68.gif"/></alternatives></inline-formula>, on its assigned slave node to return its intermediate result of size <inline-formula id="IEq69"><alternatives><tex-math id="M141">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{IRRQP}_x$$\end{document}</tex-math><mml:math id="M142"><mml:msub><mml:mi mathvariant="italic">IRRQP</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq69.gif"/></alternatives></inline-formula>.</p></list-item><list-item><p><inline-formula id="IEq70"><alternatives><tex-math id="M143">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{MT}(\textit{DRQP}_{xy})$$\end{document}</tex-math><mml:math id="M144"><mml:mrow><mml:mi mathvariant="italic">MT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="italic">DRQP</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq70.gif"/></alternatives></inline-formula>: represents the required time to move (transfer) intermediate results from a node executing a decomposed plan <inline-formula id="IEq71"><alternatives><tex-math id="M145">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{DRQP}_x$$\end{document}</tex-math><mml:math id="M146"><mml:msub><mml:mi mathvariant="italic">DRQP</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq71.gif"/></alternatives></inline-formula> into a node executing the decomposed plan <inline-formula id="IEq72"><alternatives><tex-math id="M147">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{DRQP}_y$$\end{document}</tex-math><mml:math id="M148"><mml:msub><mml:mi mathvariant="italic">DRQP</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq72.gif"/></alternatives></inline-formula>. In practice, the cost of data transfer is a dominant factor in any distributed system, therefore, the DG-SPARQL query optimizer typically chooses to move the data from the node with the smaller intermediate result size to the node with the highest intermediate result in order to reduce the data transfer cost. In other words, <inline-formula id="IEq73"><alternatives><tex-math id="M149">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{MT}(\textit{DRQP}_{xy}) = min (\textit{IRRQP}_x, \textit{IRRQP}_y)$$\end{document}</tex-math><mml:math id="M150"><mml:mrow><mml:mi mathvariant="italic">MT</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="italic">DRQP</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="italic">IRRQP</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="italic">IRRQP</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq73.gif"/></alternatives></inline-formula>.</p></list-item><list-item><p><inline-formula id="IEq74"><alternatives><tex-math id="M151">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{JT}(\textit{RQP}_{xy})$$\end{document}</tex-math><mml:math id="M152"><mml:mrow><mml:mi mathvariant="italic">JT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="italic">RQP</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq74.gif"/></alternatives></inline-formula>: represents the time to join two intermediate results produced by the two decomposed plans <inline-formula id="IEq75"><alternatives><tex-math id="M153">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{DRQP}_x$$\end{document}</tex-math><mml:math id="M154"><mml:msub><mml:mi mathvariant="italic">DRQP</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq75.gif"/></alternatives></inline-formula> and <inline-formula id="IEq76"><alternatives><tex-math id="M155">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{DRQP}_y$$\end{document}</tex-math><mml:math id="M156"><mml:msub><mml:mi mathvariant="italic">DRQP</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq76.gif"/></alternatives></inline-formula>.</p></list-item></list>In practice, all decomposed plans would initially run in parallel, however, depending on the dependency graph between the decomposed plans, some of the decomposed plan are not able to start joining their intermediate results with the intermediate result of an external node until it finishes the generation of its intermediate results and is receiving the intermediate results from the external node. As a result, using the dependency graphs of the decomposition plans and the estimated costs for its various components, the query optimizer can estimate the total execution times of each decomposition plan, <inline-formula id="IEq77"><alternatives><tex-math id="M157">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\textit{TT}(D_i)$$\end{document}</tex-math><mml:math id="M158"><mml:mrow><mml:mi mathvariant="italic">TT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="40064_2016_2251_Article_IEq77.gif"/></alternatives></inline-formula>, and choose the plan with the lowest cost for actual execution. It should be also noted that the query optimizer takes into consideration the number of available nodes for the various relational-based query plans and their various associated decompositions in a way that the total number of decomposed plans of all relational-based query plans should not exceed the number of the available (<italic>n</italic>) relational stores of the slave nodes.</p>
        <p>In principle, the basic implementation of the DG-SPARQL query execution engine relies on BSP-based main memory traversal algorithms for evaluating the traversal-based operators (e.g., reachability and shortest path operators). However, it should be noted that the DG-SPARQL query execution engine remains agnostic to the physical execution of the logical traversal operators and is able leverage any available indexing information to improve the query evaluation process of the different types of queries by taking into consideration the trade-off of building and maintaining their indices in addition to their main memory consumption. For example, distributed graph indexing and query answering techniques&#xA0;(Fan et&#xA0;al. <xref ref-type="bibr" rid="CR14">2012</xref>) can be leveraged for accelerating the execution of the traversal-based operators. However, such indexing methods can be only considered in the cases where there are no restrictions or conditions on the nodes and edges of the results of the operators as these indexing methods usually do not consider such filtering or predicate evaluation functionalities in their design.</p>
      </sec>
    </sec>
    <sec id="Sec9">
      <title>Experimental evaluation</title>
      <p>We implemented DG-SPARQL using C++ and MPICH,<xref ref-type="fn" rid="Fn3">3</xref> a high performance implementation of the Message Passing Interface (MPI). The implementation includes the query language parser and compiler, cost-based query optimizer, and distributed query execution engine. We used the IBM DB2 RDBMS for storage, indexing and performing all SQL-based query evaluation. We implemented a BSP-based version of the breadth-first graph traversal algorithm which is used for evaluating our traversal-based reachability and shortest path operators&#xA0;(Redekopp et&#xA0;al. <xref ref-type="bibr" rid="CR43">2013</xref>). In this section, we present our experimental evaluation for DG-SPARQL. The main objective of our experimental evaluation is to assess two main aspects: the system performance scalability on handling big attributed graphs in addition to comparing the system performance with Apache Giraph,<xref ref-type="fn" rid="Fn4">4</xref> a popular distributed graph processing system which is built on top of the Hadoop framework.<xref ref-type="fn" rid="Fn5">5</xref></p>
      <sec id="Sec10">
        <title>Experimental setup</title>
        <sec id="Sec11">
          <title>Experimental environment</title>
          <p>Our experiments have been conducted on a cluster of 20 nodes in addition to one node that servers as the system coordinator and client. Each server has an Intel QuadCore 2.9 GHz CPU, 16 GB of main memory storage, 1 TB of SCSI secondary storage and runs the 64-bit Fedora 13 Linux operating system, MPICH 3.0.4. For the comparison with Apache Giraph Systems, we have been using Apache Hadoop 2.6.0, Apache Giraph 1.1.0 and Java version 7.</p>
        </sec>
        <sec id="Sec12">
          <title>Dataset</title>
          <p>In our experiments, we used two main datasets:<list list-type="bullet"><list-item><p>The popular LUBM benchmark&#xA0;(<xref ref-type="bibr" rid="CR58">2014</xref>) which provides an ontology for academic information (e.g., universities). This is a <italic>synthetic</italic> dataset that can be generated with various sizes by controlling the number of generated universities. The original data generator of the benchmark generates the dataset according to the RDF graph model. Therefore, we have modified the data generator of the benchmark to generate the dataset according to the attributed graph model.<xref ref-type="fn" rid="Fn6">6</xref> In order to evaluate the scalability of our system, we generated four datasets at different scales with 20K (D1), 30K (D2), 40K (D3), and 50K (D4) universities with 450 GB, 700 GB, 950 GB and 1.2 TB of data, respectively. The datasets have been partitioned across the 20 nodes using the METIS partitioner&#xA0;(METIS <xref ref-type="bibr" rid="CR36">2014</xref>).</p></list-item><list-item><p>The <italic>real</italic> DBpedia 3.8 dataset.<xref ref-type="fn" rid="Fn7">7</xref> We converted the RDF data model of this dataset into a property graph data model using the following mechanism&#xA0;(Sun et&#xA0;al. <xref ref-type="bibr" rid="CR57">2015</xref>):<list list-type="bullet"><list-item><p>Each subject or object node in the RDF graph becomes a vertex with a unique integer ID in the property graph.</p></list-item><list-item><p>Object properties in the RDF graph are represented as adjacency edges in the property graph, where the source and the target of the edge were vertex IDs, and the edge was identified by an integer ID.</p></list-item><list-item><p>Datatype properties in the RDF graph were are represented as attributes in the property graph.</p></list-item><list-item><p>Provenance or context information are represented as attributes for the graph edges.</p></list-item></list></p></list-item></list></p>
          <p>For the sake of measuring the performance speed-up of the query execution time in response to increasing the number of slave machines, we have partitioned this dataset three times into 2, 4 and 6 partitions using the METIS partitioner&#xA0;(METIS <xref ref-type="bibr" rid="CR36">2014</xref>).</p>
        </sec>
        <sec id="Sec13">
          <title>Workload</title>
          <p>In practice, there is no defined standard benchmarks for evaluating the performance of query engines for attributed graphs&#xA0;(Sakr et&#xA0;al. <xref ref-type="bibr" rid="CR48">2014</xref>). Therefore, we defined four main categories of attributed graph queries which we used in our evaluation. These categories are described as follows:<list list-type="bullet"><list-item><p>QT1&#x2014;<italic>Highly Selective Pattern Matching Queries</italic>: This category represents a connected graph pattern (e.g., path, star, subgraph) with highly selective predicates that matches to a small set of answers.</p></list-item><list-item><p>QT2&#x2014;<italic>Low Selective Pattern Matching Queries</italic>: This category represents a connected graph pattern with low selective predicates that matches to a large set of answers.</p></list-item><list-item><p>QT3&#x2014;<italic>Pattern Matching Queries Combined With Traversal-Based Operators</italic>: Combines graph pattern searches with one or more traversal-based operators (e.g., rechability checks, shortest path).</p></list-item><list-item><p>QT4&#x2014;<italic>Pattern Matching Queries Combined With Traversal-Based Operators and Path Filtering Operations</italic>: Combines graph pattern searches with one or more traversal-based operators in addition to applying filtering predicates on the traversed paths by the traversal-based operators.</p></list-item></list>For each query type, we assigned random literal values of the query templates in order to generate different query instances. Each query template is instantiated 20 times where the data values are generated randomly.</p>
        </sec>
        <sec id="Sec14">
          <title>Performance evaluation metric</title>
          <p>Our main performance metric is the query execution time.</p>
          <p>In particular, each query instantiation of the experimental workload has been executed 5 times over our implementation and the Apache Giraph system, and execution times were collected. All times are in seconds. In order to to ensure that any caching or system process activity would not affect the collected results, the longest and shortest times for each instantiation were dropped and the remaining three execution times for the 20 instantiations were averaged.</p>
        </sec>
      </sec>
      <sec id="Sec15">
        <title>Experimental results</title>
        <p>
          <fig id="Fig7">
            <label>Fig. 7</label>
            <caption>
              <p>Average query execution times of DG-SPARQL VS Giraph on LUMB datasets <bold>a</bold> Query Type QT1 <bold>b</bold> Query Type QT2 <bold>c</bold> Query Type QT3 <bold>d</bold> Query Type QT4</p>
            </caption>
            <graphic xlink:href="40064_2016_2251_Fig7_HTML" id="MO13"/>
          </fig>
        </p>
        <p>Figure&#xA0;<xref rid="Fig7" ref-type="fig">7</xref> illustrates the average query execution times on DG-SPARQL and Giraph for the 20 instances of each of the identified four query types on the four experimental datasets of the LUMB benchmark. The results of the experiments show that DG-SPARQL is able to outperform Giraph with orders of magnitudes on the various query types. It also shows that DG-SPARQL is able to scale well to handle the increasing datasets of the LUMB benchmark.</p>
        <p>To better understand the underlying factors for the performance improvement of DG-SPARQL over Giraph, we looked closer at the details of each query. In particular, for QT1 (Fig. <xref rid="Fig7" ref-type="fig">7</xref>a), highly selective pattern matching queries, the main strategy of DG-SPARQL is to translate the query plan of this type of queries into an SQL query which is <italic>centrally</italic> executed on one of the underlying RDBMS nodes. In principle, this type of query does not involve any graph traversal operations, therefore, it does not require any message exchange between the cluster nodes. In addition, due to the high selectivity of its query predicates, RDBMS can effectively utilize its solid indexing infrastructure for efficient evaluation. Therefore, for this type of query, DG-SPARQL has shown the highest order of magnitudes in performance improvement of G-SPARQL over Giraph. Additionally, the percentage of performance improvement has increased as the size of the processed graph dataset increased.</p>
        <p>For QT2 (Fig. <xref rid="Fig7" ref-type="fig">7</xref>b), low selective pattern matching queries, the strategy of DG-SPARQL is to translate the query plan of this type of queries into an SQL query with a <italic>distributed</italic> execution plan on more than one of the underlying RDBMS nodes. Similar to QT1, QT2 does not involve any graph traversal operations, however, due to the distributed execution of the SQL queries, the evaluation of such a query type requires some form of message exchange and data shuffle operation to be performed between the nodes of the cluster which are involved in the query evaluation. Thus, for this type of queries, DG-SPARQL is still able to scale better and outperforms Giraph with orders of magnitudes, however, the percentage of improvement on QT2 is lower than the percentage of improvement on QT1, which is centrally executed and does not involve any network communication overhead.</p>
        <p>QT3 (Fig. <xref rid="Fig7" ref-type="fig">7</xref>c) combines pattern matching operations with traversal-based operations, thus, DG-SPARQL splits the query execution plan for this type of queries into multiple sub-plans where some of these plans are represented as SQL queries and their execution is pushed to the underlying RDBMS nodes while some other plans are evaluated using the BSP-based BFS traversal&#xA0;(Redekopp et&#xA0;al. <xref ref-type="bibr" rid="CR43">2013</xref>). Based on the cost model, the execution of each SQL-based query plan can be centralized on a single RDBMS node or distributed over more than one node. The same strategy is applied for the queries which belong to query type, QT4 (Fig. <xref rid="Fig7" ref-type="fig">7</xref>d). The main difference between query types, QT3 and QT4, is the execution of the path filtering condition on QT4 requires a post-processing step, after determining all the connecting paths between each pair of vertices, to evaluate the filtering predicates on the retrieved paths. For both query types, DG-SPARQL is also able to scale better and outperforms Giraph with order of magnitudes, however, the percentage of improvement on QT4 is the lowest among the four query types due to the network communication overhead and the post processing steps.<fig id="Fig8"><label>Fig. 8</label><caption><p>Speed-up improvement of query execution time in response to increasing the number of slave nodes (partitions)</p></caption><graphic xlink:href="40064_2016_2251_Fig8_HTML" id="MO14"/></fig></p>
        <p>Figure&#xA0;<xref rid="Fig8" ref-type="fig">8</xref> illustrates the average query execution times on DG-SPARQL for 20 instances of each of the identified four query types on the DBpedia real dataset. In order to evaluate the speed-up improvement of query execution time in response to increasing the number of slave nodes (partitions), we have repeated this experiment three times using 2, 4 and 6 slave nodes. The results of the experiments show that the percentage of speedup improvement varies from one query type to another. For example, for QT1, the query plan of this type of queries is translated into a single SQL query which is centrally executed on one of the underlying RDBMS nodes. Therefore, increasing the number of underlying slave nodes does not introduce any speedup improvement for the query execution time of such type of queries. Queries of query type QT2 achieve the highest percentage of speedup improvement by increasing the number of the underlying slave nodes due to their <italic>distributed</italic> execution plans over the underlying RDBMS nodes. In particular, increasing the number of slave nodes from 2 to 4 leads to 34&#xA0;% speedup improvement while increasing the number of slave nodes from 2 to 6 leads to 59&#xA0;% speedup improvement on the query execution times. Queries of query types QT3 and QT4 achieve comparable percentage of speedup improvement by increasing the number of the underlying slave nodes due to due to the network communication overhead and the post processing steps of their query plans. In particular, for QT3, increasing the number of slave nodes from 2 to 4 leads to 24&#xA0;% speedup improvement while increasing the number of slave nodes from 2 to 6 leads to 43&#xA0;% speedup improvement on the query execution times. For QT4, increasing the number of slave nodes from 2 to 4 leads to 25&#xA0;% speedup improvement while increasing the number of slave nodes from 2 to 6 leads to 44&#xA0;% speedup improvement on the query execution times. It should be noted that increasing the number of slave nodes does not necessarily lead to increasing the speedup improvement on the query execution times as the number of relational-based sub-query plans can be less than the number of slave machines. In this case, increasing the number of slave nodes does not lead to speedup improvement on the query execution time for this type of queries. In addition, increasing the number of slave nodes leads to an increase in the overhead of the message exchange between the cluster nodes. This overhead affects having a linear relationship between the number of slave nodes and query execution time.</p>
      </sec>
    </sec>
    <sec id="Sec16">
      <title>Related work</title>
      <p>Several languages were introduced for querying various kinds of graph models with various aims and querying constructs. For instance, <italic>GraphQL</italic>&#xA0;(He and Singh <xref ref-type="bibr" rid="CR24">2008</xref>) is a graph query language that relies on graph patterns as the fundamental querying units. The language design has mainly focused on manipulating and querying labeled directed graphs. The <italic>GraphDB</italic>&#xA0;(G&#xFC;ting <xref ref-type="bibr" rid="CR21">1994</xref>) language has been designed to support spatial networks (e.g., transportation systems) based on the availability of a graph schema. GraphDB querying abstractions rely on object-oriented concepts including classes for vertices, edges and paths. It supports regular expressions that are specified over sequences of vertex and edge types. SoQL (social networks query language)&#xA0;(Ronen and Shmueli <xref ref-type="bibr" rid="CR45">2009</xref>) has been presented as an SQL-like language for querying social networks. SoQL provides its users with the ability to retrieve paths and use these retrieved paths to create new connections with the retrieved nodes which are located at the end of the paths. The language also enables to formulate complex conditions over the retrieved paths. <italic>PQL</italic>&#xA0;(Leser <xref ref-type="bibr" rid="CR34">2005</xref>) has been designed as a special-purpose language that is focused around querying pathways of biological networks.</p>
      <p><italic>GRAPHiQL</italic>&#xA0;(Jindal and Madden <xref ref-type="bibr" rid="CR29">2014</xref>) has been introduced as another SQL-like general purpose graph processing language. GRAPHiQL provides its user with the ability to reason about graphs in terms of the intuitive abstraction of vertices and edges. It also provides optimized graph querying constructs such as recursion, looping, neighborhood access. The GRAPHiQL execution engine compiles the user query into SQL query that is executed by a standard relational engine and relies on query optimization techniques to tune the performance of these queries. <italic>Green-Marl</italic>&#xA0;(Hong et&#xA0;al. <xref ref-type="bibr" rid="CR26">2012</xref>) has been presented as a domain-specific language (DSL) with high level language constructs that enables its users to express their graph querying operations. The execution engine of Green-Marl translates the user programs into efficient C++ code that exploits data level parallelism and the high-level semantic knowledge of the language constructs. <italic>G-Path</italic>&#xA0;(Bai et&#xA0;al. <xref ref-type="bibr" rid="CR2">2013</xref>) has been introduced as a path-based query language on large graphs. The execution engine of G-Path is designed on top of the Hadoop framework&#xA0;(Sakr et&#xA0;al. <xref ref-type="bibr" rid="CR49">2013</xref>) and bulk synchronized parallel model&#xA0;(Batarfi et&#xA0;al. <xref ref-type="bibr" rid="CR4">2015</xref>) where it executes general graph queries in the absence of any indexing information. <italic>Gremlin</italic>&#xA0;(<xref ref-type="bibr" rid="CR19">2015</xref>), <italic>Cypher</italic>&#xA0;(<xref ref-type="bibr" rid="CR11">2015</xref>) and <italic>Horton</italic>&#xA0;(Sarwat et&#xA0;al. <xref ref-type="bibr" rid="CR55">2012</xref>) are examples of other path-based languages which are used for graph traversals. <italic>Horton+</italic>&#xA0;(Sarwat et&#xA0;al. <xref ref-type="bibr" rid="CR54">2013</xref>) has been implemented as a distributed execution engine for Horton queries that fully manages the graph using the main memory of a cluster of nodes. In practice, path-based languages may limit the ability of its users to only think in terms of paths and constrain their ability to express broader graph querying operations. <italic>SQLGraph</italic>&#xA0;(Sun et&#xA0;al. <xref ref-type="bibr" rid="CR57">2015</xref>) has been presented as an approach that exploits both relational and non-relational storage for property graphs. In particular, it uses relational storage for adjacency information and JSON storage for vertex and edge attributes. SQLGraph applies a query translation mechanism that translates Gremlin queries&#xA0;(<xref ref-type="bibr" rid="CR19">2015</xref>) into SQL queries and leverage relational query optimizers and execution engines for evaluating the queries. <italic>GRAPHITE</italic>&#xA0;(Chau et&#xA0;al. <xref ref-type="bibr" rid="CR8">2008</xref>) has been presented as a visual system for querying graph patterns and locates both exact and approximate subgraph matches in large attributed graphs. <italic>VOGUE</italic>&#xA0;(Bhowmick et&#xA0;al. <xref ref-type="bibr" rid="CR5">2013</xref>) is another visual human computer interaction(HCI)-aware subgraph query engines that interleaves visual query construction and query processing with the aim of improving the user experience and performance of query execution.</p>
      <p>For about a decade, the Hadoop framework has often been considered as the de facto standard in the domain of general distributed computation and big data processing&#xA0;(Sakr et&#xA0;al. <xref ref-type="bibr" rid="CR49">2013</xref>). In general, the MapReduce programming model of the Hadoop framework is able to implement many common graph querying and processing operations. However, the Hadoop framework has shown to have limited practicality in the context of big graph processing. In practice, graph processing algorithms are mostly iterative in nature and require the traversal of the graph in a particular form. Using the Hadoop framework, this could be implemented via a sequence of job invocations which passes the whole state of the graph from one step to the following. However, such mechanism is not adequate for graph processing and leads to inefficient performance because of the associated serialization and communication overheads&#xA0;(Batarfi et&#xA0;al. <xref ref-type="bibr" rid="CR4">2015</xref>). To solve this inherent performance problem of the Hadoop framework, several specialized platforms which are designed to serve the unique processing requirements of large-scale graph processing have been introduced. These systems provide programmatic abstractions for performing iterative parallel analysis of large graphs on clustered systems&#xA0;(Batarfi et&#xA0;al. <xref ref-type="bibr" rid="CR4">2015</xref>).</p>
      <p>In general, vertex-centric models express the graph processing job from a vertex perspective where they are executed iteratively for each vertex in the graph. The <italic>Pregel</italic> system&#xA0;(Malewicz et&#xA0;al. <xref ref-type="bibr" rid="CR37">2010</xref>), introduced by Google, has pioneered the domain of large scale graph processing systems using the Bulk Synchronous Parallel (BSP) programming model and by relying on a &#x201C;<italic>think like a vertex</italic>&#x201D; programming model. The introduction of Google&#x2019;s Pregel has triggered a lot of interest in the domain of large-scale graph processing and inspired the development of several Pregel-based systems which have been attempting to exploit different optimization opportunities. For example, <italic>Apache Giraph</italic><xref ref-type="fn" rid="Fn8">8</xref> is an open source project that clones the ideas and implementation of the Pregel specification in Java on top of the infrastructure of the Hadoop framework. <italic>GPS</italic>&#xA0;(Salihoglu and Widom <xref ref-type="bibr" rid="CR53">2013</xref>), and <italic>Giraph</italic>++&#xA0;(Tian et&#xA0;al. <xref ref-type="bibr" rid="CR59">2013</xref>) are examples of other systems that have been presented as enhancements/extensions for the Pregel system in various aspects. <italic>Trinity</italic>&#xA0;(Shao et&#xA0;al. <xref ref-type="bibr" rid="CR56">2013</xref>) is a memory-based distributed system with the aims of optimizing memory and communication cost under the assumption that the entire graph is partitioned over a memory cloud. <italic>GraphX</italic>&#xA0;(Gonzalez et&#xA0;al. <xref ref-type="bibr" rid="CR16">2014</xref>) is a distributed graph processing system which is implemented on top of the Spark framework&#xA0;(Zaharia et&#xA0;al. <xref ref-type="bibr" rid="CR62">2010</xref>). Other general purpose distributed graph processing systems include <italic>Pregelix</italic>&#xA0;(Bu et&#xA0;al. <xref ref-type="bibr" rid="CR7">2014</xref>), <italic>GRACE</italic>&#xA0;(Wang et&#xA0;al. <xref ref-type="bibr" rid="CR61">2013</xref>), <italic>NScale</italic>&#xA0;(Quamar et&#xA0;al. <xref ref-type="bibr" rid="CR42">2014</xref>), <italic>GraphLab</italic>&#xA0;(Low et&#xA0;al. <xref ref-type="bibr" rid="CR35">2012</xref>) and <italic>PowerGraph</italic>&#xA0;(Gonzalez et&#xA0;al. <xref ref-type="bibr" rid="CR15">2012</xref>). In general, these group of systems are mainly designed for batch processing of large scale graph computations rather than online graph querying. In addition, they lack any declarative interfaces and thus they require their users to be experienced programmers to write efficient programs that acknowledge deep understanding of the programming model and the underlying system details.</p>
      <p>In addition to the distributed graph processing platforms, <italic>NXgraph</italic>&#xA0;(Chi et&#xA0;al. <xref ref-type="bibr" rid="CR9">2015</xref>), <italic>GraphChi</italic>&#xA0;(Kyrola et&#xA0;al. <xref ref-type="bibr" rid="CR33">2012</xref>) and <italic>TurboGraph</italic>&#xA0;(Han et&#xA0;al. <xref ref-type="bibr" rid="CR23">2013</xref>) have been presented as <italic>centralized</italic> systems to process large graphs that are stored in the secondary storage of a single node. However, several experimental studies have shown the performance and scalability limitations of the centralized graph processing systems&#xA0;(Barnawi et&#xA0;al. <xref ref-type="bibr" rid="CR3">2014</xref>), (Koch et&#xA0;al. <xref ref-type="bibr" rid="CR31">2015</xref>). Several centralized&#xA0;(Abadi et&#xA0;al. <xref ref-type="bibr" rid="CR1">2007</xref>; Br&#xF6;cheler et&#xA0;al. <xref ref-type="bibr" rid="CR6">2009</xref>; Neumann and Weikum <xref ref-type="bibr" rid="CR38">2008</xref>; Zou et&#xA0;al. <xref ref-type="bibr" rid="CR65">2011</xref>) and distributed&#xA0;(Hammoud et&#xA0;al. <xref ref-type="bibr" rid="CR22">2015</xref>; Rohloff and Schantz <xref ref-type="bibr" rid="CR44">2010</xref>; Jiewen et&#xA0;al. <xref ref-type="bibr" rid="CR27">2011</xref>; Zeng et&#xA0;al. <xref ref-type="bibr" rid="CR63">2013</xref>; Papailiou et&#xA0;al. <xref ref-type="bibr" rid="CR39">2013</xref>) SPARQL query engines for the RDF graph data model have been proposed. However, these systems can not be directly reused in the context of attributed graph because of the various differences in the data model and querying requirements. Moreover, several centralized graph database systems (e.g. Neo4j,<xref ref-type="fn" rid="Fn9">9</xref> HypergraphDB<xref ref-type="fn" rid="Fn10">10</xref>) have also been introduced. However, such systems can not scale to deal with the performance requirements of querying large graphs.</p>
    </sec>
    <sec id="Sec17">
      <title>Conclusion</title>
      <p>In this article, we presented DG-SPARQL, an efficient distributed query engine for the G-SPARQL query language which is able to handle big attributed graphs. DG-SPARQL relies on an efficient hybrid Memory/Disk representation of large attributed graphs where only the topology of the graph is maintained in the distributed memory of computing clusters while the data of the graph are stored in a relational database. The DG-SPARQL query execution engine relies on a cost model to split the execution plan into relational-based plans and main memory-based plans. In addition, using the cost model, the query execution engine can adaptively switch the execution of the plans between being centralized or distributed based on which is the more efficient model. Our experimental evaluation validated the efficiency and scalability of our approach and showed that DG-SPARQL is a scalable engine that works for massive graphs. Due to the complexity of graph query languages, in our future work, we are planning to support visual query interfaces&#xA0;(Hung et&#xA0;al. <xref ref-type="bibr" rid="CR28">2014</xref>) that can reduce the burden of query formulation and ease the process for different types of non-technical users.</p>
    </sec>
  </body>
  <back>
    <fn-group>
      <fn id="Fn1">
        <label>1</label>
        <p><ext-link ext-link-type="uri" xlink:href="http://venturebeat.com/2015/04/22/facebook-passes-1-44b-monthly-active-users-1-25b-mobile-users-and-936-million-daily-users/">http://venturebeat.com/2015/04/22/facebook-passes-1-44b-monthly-active-users-1-25b-mobile-users-and-936-million-daily-users/</ext-link>.</p>
      </fn>
      <fn id="Fn2">
        <label>2</label>
        <p>Throughout the paper, we use the words node and vertex interchangeably.</p>
      </fn>
      <fn id="Fn3">
        <label>3</label>
        <p><ext-link ext-link-type="uri" xlink:href="https://www.mpich.org/">https://www.mpich.org/</ext-link>.</p>
      </fn>
      <fn id="Fn4">
        <label>4</label>
        <p><ext-link ext-link-type="uri" xlink:href="http://giraph.apache.org/">http://giraph.apache.org/</ext-link>.</p>
      </fn>
      <fn id="Fn5">
        <label>5</label>
        <p><ext-link ext-link-type="uri" xlink:href="https://hadoop.apache.org/">https://hadoop.apache.org/</ext-link>.</p>
      </fn>
      <fn id="Fn6">
        <label>6</label>
        <p>The main extension is to generate attribute/value pairs for the graph edges.</p>
      </fn>
      <fn id="Fn7">
        <label>7</label>
        <p><ext-link ext-link-type="uri" xlink:href="http://wiki.dbpedia.org/services-resources/datasets/data-set-38/downloads-38">http://wiki.dbpedia.org/services-resources/datasets/data-set-38/downloads-38</ext-link>.</p>
      </fn>
      <fn id="Fn8">
        <label>8</label>
        <p><ext-link ext-link-type="uri" xlink:href="http://giraph.apache.org/">http://giraph.apache.org/</ext-link>.</p>
      </fn>
      <fn id="Fn9">
        <label>9</label>
        <p><ext-link ext-link-type="uri" xlink:href="http://neo4j.org/">http://neo4j.org/</ext-link>.</p>
      </fn>
      <fn id="Fn10">
        <label>10</label>
        <p><ext-link ext-link-type="uri" xlink:href="http://www.kobrix.com/hgdb.jsp">http://www.kobrix.com/hgdb.jsp</ext-link>.</p>
      </fn>
    </fn-group>
    <ack>
      <title>Authors&#x2019; contributions</title>
      <p>OB carried out the analysis of the query language and the design of the cost model. RE carried out identifying the various important statistical information for supporting the cost model. AF carried out the analysis of the logical query plans. AB and SS carried on the implementation the evaluation of the distributed query execution engine. All authors read and approved the final manuscript.</p>
      <sec id="d30e3715">
        <title>Acknowledgements</title>
        <p>This work was supported by King Abdulaziz City for Science and Technology (KACST) project 11-INF1990-03.</p>
      </sec>
      <sec id="d30e3720">
        <title>Competing interests</title>
        <p>The authors declare that they have no competing interests.</p>
      </sec>
    </ack>
    <ref-list id="Bib1">
      <title>References</title>
      <ref id="CR1">
        <mixed-citation publication-type="other">Abadi DJ, Marcus A, Madden S, Hollenbach KJ (2007) Scalable semantic web data management using vertical partitioning. In: Proceedings of the 33rd international conference on very large data bases, University of Vienna, Austria, September 23&#x2013;27, 2007, pp 411&#x2013;422</mixed-citation>
      </ref>
      <ref id="CR2">
        <mixed-citation publication-type="other">Bai Y, Wang C, Ning Y, Wu H, Wang H (2013) G-path: flexible path pattern query on large graphs. In: 22nd international world wide web conference, WWW &#x2019;13, Rio de Janeiro, Brazil, May 13&#x2013;17, 2013, companion volume, pp 333&#x2013;336</mixed-citation>
      </ref>
      <ref id="CR3">
        <mixed-citation publication-type="other">Barnawi A, Batarfi O, Behteshi S, Elshawi R, Fayoumi A, Nouri R, Sakr S (2014) On characterizing the performance of distributed graph computation platforms. In: TPCTC</mixed-citation>
      </ref>
      <ref id="CR4">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Batarfi</surname>
              <given-names>O</given-names>
            </name>
            <name>
              <surname>El Shawi</surname>
              <given-names>R</given-names>
            </name>
            <name>
              <surname>Fayoumi</surname>
              <given-names>AG</given-names>
            </name>
            <name>
              <surname>Nouri</surname>
              <given-names>R</given-names>
            </name>
            <name>
              <surname>Seyed-Mehdi-Reza</surname>
              <given-names>B</given-names>
            </name>
            <name>
              <surname>Ahmed</surname>
              <given-names>B</given-names>
            </name>
            <name>
              <surname>Sherif</surname>
              <given-names>S</given-names>
            </name>
          </person-group>
          <article-title>Large scale graph processing systems: survey and an experimental evaluation</article-title>
          <source>Clust Comput</source>
          <year>2015</year>
          <volume>18</volume>
          <issue>3</issue>
          <fpage>1189</fpage>
          <lpage>1213</lpage>
          <pub-id pub-id-type="doi">10.1007/s10586-015-0472-6</pub-id>
        </element-citation>
      </ref>
      <ref id="CR5">
        <mixed-citation publication-type="other">Bhowmick SS, Choi B, Zhou S (2013) VOGUE: towards a visual interaction-aware graph query processing framework. In: CIDR 2013, Sixth biennial conference on innovative data systems research, Asilomar, CA, USA, January 6&#x2013;9, 2013, Online proceedings</mixed-citation>
      </ref>
      <ref id="CR6">
        <mixed-citation publication-type="other">Br&#xF6;cheler M, Pugliese A, Subrahmanian VS (2009) DOGMA: a disk-oriented graph matching algorithm for RDF databases. In: ISWC</mixed-citation>
      </ref>
      <ref id="CR7">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Bu</surname>
              <given-names>Y</given-names>
            </name>
            <name>
              <surname>Borkar</surname>
              <given-names>VR</given-names>
            </name>
            <name>
              <surname>Jia</surname>
              <given-names>J</given-names>
            </name>
            <name>
              <surname>Carey</surname>
              <given-names>MJ</given-names>
            </name>
          </person-group>
          <article-title>Pregelix: big(ger) graph analytics on a dataflow engine</article-title>
          <source>PVLDB</source>
          <year>2014</year>
          <volume>8</volume>
          <issue>2</issue>
          <fpage>161</fpage>
          <lpage>172</lpage>
        </element-citation>
      </ref>
      <ref id="CR8">
        <mixed-citation publication-type="other">Chau DH, Faloutsos C, Tong H, Hong JI, Gallagher B, Eliassi-Rad T (2008) GRAPHITE: a visual query system for large graphs. In: Workshops proceedings of the 8th IEEE international conference on data mining (ICDM 2008), December 15&#x2013;19, 2008. Pisa, Italy, pp 963&#x2013;966</mixed-citation>
      </ref>
      <ref id="CR9">
        <mixed-citation publication-type="other">Chi Y, Dai G, Yu W, Sun G, Li G, Yang H (2015) NXgraph: an efficient graph processing system on a single machine. <italic>CoRR</italic>, abs/1510.06916</mixed-citation>
      </ref>
      <ref id="CR10">
        <mixed-citation publication-type="other">Copeland GP, Khoshafian S (1985) A decomposition storage model. In: Proceedings of the 1985 ACM SIGMOD international conference on management of data, Austin, Texas, May 28&#x2013;31, 1985, pp 268&#x2013;279</mixed-citation>
      </ref>
      <ref id="CR11">
        <mixed-citation publication-type="other">Cypher Query Language (2015) <ext-link ext-link-type="uri" xlink:href="http://neo4j.com/docs/stable/cypher-query-lang.html">http://neo4j.com/docs/stable/cypher-query-lang.html</ext-link></mixed-citation>
      </ref>
      <ref id="CR12">
        <mixed-citation publication-type="other">Ehrig H, Prange U, Taentzer G (2004) Fundamental theory for typed attributed graph transformation. In: Graph transformations, pp 161&#x2013;177</mixed-citation>
      </ref>
      <ref id="CR13">
        <mixed-citation publication-type="other">Faloutsos M, Faloutsos P, Faloutsos C (1999) On power-law relationships of the internet topology. In: SIGCOMM, pp 251&#x2013;262</mixed-citation>
      </ref>
      <ref id="CR14">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Fan</surname>
              <given-names>W</given-names>
            </name>
            <name>
              <surname>Wang</surname>
              <given-names>X</given-names>
            </name>
            <name>
              <surname>Wu</surname>
              <given-names>Y</given-names>
            </name>
          </person-group>
          <article-title>Performance guarantees for distributed reachability queries</article-title>
          <source>PVLDB</source>
          <year>2012</year>
          <volume>5</volume>
          <issue>11</issue>
          <fpage>1304</fpage>
          <lpage>1315</lpage>
        </element-citation>
      </ref>
      <ref id="CR15">
        <mixed-citation publication-type="other">Gonzalez JE, Low Y, Gu H, Bickson D, Guestrin C (2012) PowerGraph: distributed graph-parallel computation on natural graphs. In: OSDI, pp 17&#x2013;30</mixed-citation>
      </ref>
      <ref id="CR16">
        <mixed-citation publication-type="other">Gonzalez JE, Xin RS, Dave A, Crankshaw D, Franklin MJ, Stoica I (2014) GraphX: graph processing in a distributed dataflow framework. In: OSDI, pp 599&#x2013;613</mixed-citation>
      </ref>
      <ref id="CR17">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Gou</surname>
              <given-names>G</given-names>
            </name>
            <name>
              <surname>Chirkova</surname>
              <given-names>R</given-names>
            </name>
          </person-group>
          <article-title>Efficiently querying large XML data repositories: a survey</article-title>
          <source>IEEE Trans Knowl Data Eng</source>
          <year>2007</year>
          <volume>19</volume>
          <issue>10</issue>
          <fpage>1381</fpage>
          <lpage>1403</lpage>
          <pub-id pub-id-type="doi">10.1109/TKDE.2007.1060</pub-id>
        </element-citation>
      </ref>
      <ref id="CR18">
        <mixed-citation publication-type="other">Graefe G (2003) Sorting and indexing with partitioned b-trees. In: CIDR</mixed-citation>
      </ref>
      <ref id="CR19">
        <mixed-citation publication-type="other">Gremlin Query Language (2015) <ext-link ext-link-type="uri" xlink:href="https://github.com/tinkerpop/gremlin/wiki">https://github.com/tinkerpop/gremlin/wiki</ext-link></mixed-citation>
      </ref>
      <ref id="CR20">
        <mixed-citation publication-type="other">Grust T, Sakr S, Teubner J (2004) Xquery on SQL hosts. In: (e)Proceedings of the thirtieth international conference on very large data bases, Toronto, Canada, August 31&#x2013;September 3, 2004, pp 252&#x2013;263</mixed-citation>
      </ref>
      <ref id="CR21">
        <mixed-citation publication-type="other">G&#xFC;ting RH (1994) GraphDB: modeling and querying graphs in databases. In: VLDB&#x2019;94, Proceedings of 20th international conference on very large data bases, September 12&#x2013;15, 1994. Santiago de Chile, Chile, pp 297&#x2013;308</mixed-citation>
      </ref>
      <ref id="CR22">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Hammoud</surname>
              <given-names>M</given-names>
            </name>
            <name>
              <surname>Rabbou</surname>
              <given-names>DA</given-names>
            </name>
            <name>
              <surname>Nouri</surname>
              <given-names>R</given-names>
            </name>
            <name>
              <surname>Beheshti</surname>
              <given-names>S-M-R</given-names>
            </name>
            <name>
              <surname>Sakr</surname>
              <given-names>S</given-names>
            </name>
          </person-group>
          <article-title>DREAM: distributed RDF engine with adaptive query planner and minimal communication</article-title>
          <source>PVLDB</source>
          <year>2015</year>
          <volume>8</volume>
          <issue>6</issue>
          <fpage>654</fpage>
          <lpage>665</lpage>
        </element-citation>
      </ref>
      <ref id="CR23">
        <mixed-citation publication-type="other">Han W-S, Lee S, Park K, Lee J-H, Kim M-S, Kim Jinha, Yu Hwanjo (2013) TurboGraph: a fast parallel graph engine handling billion-scale graphs in a single PC. In: KDD, pp 77&#x2013;85</mixed-citation>
      </ref>
      <ref id="CR24">
        <mixed-citation publication-type="other">He H, Singh AK (2008) Graphs-at-a-time: query language and access methods for graph databases. In: ACM SIGMOD, pp 405&#x2013;418</mixed-citation>
      </ref>
      <ref id="CR25">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Hendrickson</surname>
              <given-names>B</given-names>
            </name>
            <name>
              <surname>Kolda</surname>
              <given-names>TG</given-names>
            </name>
          </person-group>
          <article-title>Graph partitioning models for parallel computing</article-title>
          <source>Parallel Comput</source>
          <year>2000</year>
          <volume>26</volume>
          <issue>12</issue>
          <fpage>1519</fpage>
          <lpage>1534</lpage>
          <pub-id pub-id-type="doi">10.1016/S0167-8191(00)00048-X</pub-id>
        </element-citation>
      </ref>
      <ref id="CR26">
        <mixed-citation publication-type="other">Hong S, Chafi H, Sedlar E, Olukotun K (2012) Green-Marl: a DSL for easy and efficient graph analysis. In: Proceedings of the 17th international conference on architectural support for programming languages and operating systems, ASPLOS 2012, London, UK, March 3&#x2013;7, 2012, pp 349&#x2013;362</mixed-citation>
      </ref>
      <ref id="CR27">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Huang</surname>
              <given-names>J</given-names>
            </name>
            <name>
              <surname>Abadi</surname>
              <given-names>DJ</given-names>
            </name>
            <name>
              <surname>Ren</surname>
              <given-names>K</given-names>
            </name>
          </person-group>
          <article-title>Scalable SPARQL querying of large RDF graphs</article-title>
          <source>PVLDB</source>
          <year>2011</year>
          <volume>4</volume>
          <issue>11</issue>
          <fpage>1123</fpage>
          <lpage>1134</lpage>
        </element-citation>
      </ref>
      <ref id="CR28">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Hung</surname>
              <given-names>HH</given-names>
            </name>
            <name>
              <surname>Bhowmick</surname>
              <given-names>SS</given-names>
            </name>
            <name>
              <surname>Truong</surname>
              <given-names>BQ</given-names>
            </name>
            <name>
              <surname>Choi</surname>
              <given-names>B</given-names>
            </name>
            <name>
              <surname>Zhou</surname>
              <given-names>S</given-names>
            </name>
          </person-group>
          <article-title>QUBLE: towards blending interactive visual subgraph search queries on large networks</article-title>
          <source>VLDB J</source>
          <year>2014</year>
          <volume>23</volume>
          <issue>3</issue>
          <fpage>401</fpage>
          <lpage>426</lpage>
          <pub-id pub-id-type="doi">10.1007/s00778-013-0322-1</pub-id>
        </element-citation>
      </ref>
      <ref id="CR29">
        <mixed-citation publication-type="other">Jindal A, Madden S (2014) GRAPHiQL: A graph intuitive query language for relational databases. In: 2014 IEEE international conference on big data, big data 2014, Washington, DC, USA, October 27&#x2013;30, pp 441&#x2013;450</mixed-citation>
      </ref>
      <ref id="CR30">
        <mixed-citation publication-type="other">Kleinberg JM, Kumar R, Raghavan P, Rajagopalan S, Tomkins A (1999) The web as a graph: measurements, models, and methods. In: COCOON, pp 1&#x2013;17</mixed-citation>
      </ref>
      <ref id="CR31">
        <mixed-citation publication-type="other">Koch J, Staudt CL, Vogel M, Meyerhenke H (2015) Complex network analysis on distributed systems: an empirical comparison. In: Proceedings of the 2015 IEEE/ACM international conference on advances in social networks analysis and mining, ASONAM 2015, Paris, France, August 25&#x2013;28, 2015, pp 1169&#x2013;1176</mixed-citation>
      </ref>
      <ref id="CR32">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Korf</surname>
              <given-names>RE</given-names>
            </name>
          </person-group>
          <article-title>Depth-first iterative-deepening: an optimal admissible tree search</article-title>
          <source>Artif Intel</source>
          <year>1985</year>
          <volume>27</volume>
          <issue>1</issue>
          <fpage>97</fpage>
          <lpage>109</lpage>
          <pub-id pub-id-type="doi">10.1016/0004-3702(85)90084-0</pub-id>
        </element-citation>
      </ref>
      <ref id="CR33">
        <mixed-citation publication-type="other">Kyrola A, Blelloch GE, Guestrin C (2012) GraphChi: large-scale graph computation on just a PC. In: OSDI, pp 31&#x2013;46</mixed-citation>
      </ref>
      <ref id="CR34">
        <mixed-citation publication-type="other">Leser U (2005) A query language for biological networks. Bioinformatics 21(Suppl 2):ii33&#x2013;9</mixed-citation>
      </ref>
      <ref id="CR35">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Low</surname>
              <given-names>Y</given-names>
            </name>
            <name>
              <surname>Gonzalez</surname>
              <given-names>J</given-names>
            </name>
            <name>
              <surname>Kyrola</surname>
              <given-names>A</given-names>
            </name>
            <name>
              <surname>Bickson</surname>
              <given-names>D</given-names>
            </name>
            <name>
              <surname>Guestrin</surname>
              <given-names>C</given-names>
            </name>
            <name>
              <surname>Hellerstein</surname>
              <given-names>JM</given-names>
            </name>
          </person-group>
          <article-title>Distributed GraphLab: a framework for machine learning in the cloud</article-title>
          <source>PVLDB</source>
          <year>2012</year>
          <volume>5</volume>
          <issue>8</issue>
          <fpage>716</fpage>
          <lpage>727</lpage>
        </element-citation>
      </ref>
      <ref id="CR36">
        <mixed-citation publication-type="other">METIS (2014) <ext-link ext-link-type="uri" xlink:href="http://glaros.dtc.umn.edu/gkhome/metis/metis/overview">http://glaros.dtc.umn.edu/gkhome/metis/metis/overview</ext-link></mixed-citation>
      </ref>
      <ref id="CR37">
        <mixed-citation publication-type="other">Malewicz G, Austern MH, Bik AJC, Dehnert JC, Horn I, Leiser N, Czajkowski G (2010) Pregel: a system for large-scale graph processing. In: SIGMOD conference, pp 135&#x2013;146</mixed-citation>
      </ref>
      <ref id="CR38">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Neumann</surname>
              <given-names>T</given-names>
            </name>
            <name>
              <surname>Weikum</surname>
              <given-names>G</given-names>
            </name>
          </person-group>
          <article-title>RDF-3X: a RISC-style engine for RDF</article-title>
          <source>PVLDB</source>
          <year>2008</year>
          <volume>1</volume>
          <issue>1</issue>
          <fpage>647</fpage>
          <lpage>659</lpage>
        </element-citation>
      </ref>
      <ref id="CR39">
        <mixed-citation publication-type="other">Papailiou N, Konstantinou I, Tsoumakos D, Karras P, Koziris N (2013) H2RDF+: high-performance distributed joins over large-scale RDF graphs. In: IEEE Big Data</mixed-citation>
      </ref>
      <ref id="CR40">
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Powers</surname>
              <given-names>S</given-names>
            </name>
          </person-group>
          <source>Practical RDF</source>
          <year>2003</year>
          <publisher-loc>Newton</publisher-loc>
          <publisher-name>O&#x2019;Reilly Media</publisher-name>
        </element-citation>
      </ref>
      <ref id="CR41">
        <mixed-citation publication-type="other">Prud&#x2019;hommeaux E, Seaborne A (2008) SPARQL Query Language for RDF, W3C Recommendation, January 2008. <ext-link ext-link-type="uri" xlink:href="http://www.w3.org/TR/rdf-sparql-query/">http://www.w3.org/TR/rdf-sparql-query/</ext-link></mixed-citation>
      </ref>
      <ref id="CR42">
        <mixed-citation publication-type="other">Quamar A, Deshpande A, Lin J (2014) NScale: neighborhood-centric analytics on large graphs. PVLDB 7(13):1673&#x2013;1676</mixed-citation>
      </ref>
      <ref id="CR43">
        <mixed-citation publication-type="other">Redekopp M, Simmhan Y, Prasanna VK (2013) Optimizations and analysis of BSP graph processing models on public clouds. In: IEEE international symposium on parallel and distributed processing, IPDPS</mixed-citation>
      </ref>
      <ref id="CR44">
        <mixed-citation publication-type="other">Rohloff K, Schantz RE (2010) High-performance, massively scalable distributed systems using the MapReduce software framework: the SHARD triple-store. In: Programming support innovations for emerging distributed applications</mixed-citation>
      </ref>
      <ref id="CR45">
        <mixed-citation publication-type="other">Ronen R, Shmueli O (2009) SoQL: a language for querying and creating data in social networks. Proceedings of the 25th international conference on data engineering, ICDE 2009, March 29, 2009&#x2013;April 2, 2009. Shanghai, China, pp 1595&#x2013;1602</mixed-citation>
      </ref>
      <ref id="CR50">
        <mixed-citation publication-type="other">Sakr S (2009) GraphREL: a decomposition-based and selectivity-aware relational framework for processing sub-graph queries. In: Database systems for advanced applications, 14th international conference, DASFAA 2009, Brisbane, Australia, April 21&#x2013;23, 2009. Proceedings, pp 123&#x2013;137</mixed-citation>
      </ref>
      <ref id="CR46">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Sakr</surname>
              <given-names>S</given-names>
            </name>
            <name>
              <surname>Al-Naymat</surname>
              <given-names>G</given-names>
            </name>
          </person-group>
          <article-title>Relational processing of RDF queries: a survey</article-title>
          <source>SIGMOD Rec</source>
          <year>2009</year>
          <volume>38</volume>
          <issue>4</issue>
          <fpage>23</fpage>
          <lpage>28</lpage>
          <pub-id pub-id-type="doi">10.1145/1815948.1815953</pub-id>
        </element-citation>
      </ref>
      <ref id="CR47">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Sakr</surname>
              <given-names>S</given-names>
            </name>
            <name>
              <surname>Al-Naymat</surname>
              <given-names>G</given-names>
            </name>
          </person-group>
          <article-title>Efficient relational techniques for processing graph queries</article-title>
          <source>J Comput Sci Technol</source>
          <year>2010</year>
          <volume>25</volume>
          <issue>6</issue>
          <fpage>1237</fpage>
          <lpage>1255</lpage>
          <pub-id pub-id-type="doi">10.1007/s11390-010-9402-5</pub-id>
        </element-citation>
      </ref>
      <ref id="CR52">
        <mixed-citation publication-type="other">Sakr S, Pardede E (2011) Graph data management: techniques and applications. IGI Global</mixed-citation>
      </ref>
      <ref id="CR51">
        <mixed-citation publication-type="other">Sakr S, Elnikety S, He Y (2012) G-SPARQL: a hybrid engine for querying large attributed graphs. In: ACM CIKM, pp 335&#x2013;344</mixed-citation>
      </ref>
      <ref id="CR49">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Sakr</surname>
              <given-names>S</given-names>
            </name>
            <name>
              <surname>Liu</surname>
              <given-names>A</given-names>
            </name>
            <name>
              <surname>Fayoumi</surname>
              <given-names>AG</given-names>
            </name>
          </person-group>
          <article-title>The family of mapreduce and large-scale data processing systems</article-title>
          <source>ACM Comput Surv</source>
          <year>2013</year>
          <volume>46</volume>
          <issue>1</issue>
          <fpage>11</fpage>
          <pub-id pub-id-type="doi">10.1145/2522968.2522979</pub-id>
        </element-citation>
      </ref>
      <ref id="CR48">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Sakr</surname>
              <given-names>S</given-names>
            </name>
            <name>
              <surname>Elnikety</surname>
              <given-names>S</given-names>
            </name>
            <name>
              <surname>He</surname>
              <given-names>Y</given-names>
            </name>
          </person-group>
          <article-title>Hybrid query execution engine for large attributed graphs</article-title>
          <source>Inf Syst</source>
          <year>2014</year>
          <volume>41</volume>
          <fpage>45</fpage>
          <lpage>73</lpage>
          <pub-id pub-id-type="doi">10.1016/j.is.2013.10.007</pub-id>
        </element-citation>
      </ref>
      <ref id="CR53">
        <mixed-citation publication-type="other">Salihoglu S, Widom J (2013) GPS: a graph processing system. In: SSDBM, pp 22</mixed-citation>
      </ref>
      <ref id="CR55">
        <mixed-citation publication-type="other">Sarwat M, Elnikety S, He Y, Kliot G (2012) Horton: online query execution engine for large distributed graphs. In: IEEE 28th international conference on data engineering (ICDE 2012), Washington, DC, USA (Arlington, Virginia), 1&#x2013;5 April, 2012, pp 1289&#x2013;1292</mixed-citation>
      </ref>
      <ref id="CR54">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Sarwat</surname>
              <given-names>M</given-names>
            </name>
            <name>
              <surname>Elnikety</surname>
              <given-names>S</given-names>
            </name>
            <name>
              <surname>He</surname>
              <given-names>Y</given-names>
            </name>
            <name>
              <surname>Mokbel</surname>
              <given-names>MF</given-names>
            </name>
          </person-group>
          <article-title>Horton+: a distributed system for processing declarative reachability queries over partitioned graphs</article-title>
          <source>PVLDB</source>
          <year>2013</year>
          <volume>6</volume>
          <issue>14</issue>
          <fpage>1918</fpage>
          <lpage>1929</lpage>
        </element-citation>
      </ref>
      <ref id="CR56">
        <mixed-citation publication-type="other">Shao B, Wang H, Li Y (2013) Trinity: a distributed graph engine on a memory cloud. In: SIGMOD, pp 505&#x2013;516</mixed-citation>
      </ref>
      <ref id="CR57">
        <mixed-citation publication-type="other">Sun W, Fokoue A, Srinivas K, Kementsietsidis A, Hu G, Xie GT (2015) SQLGraph: an efficient relational-based property graph store. In: SIGMOD, pp 1887&#x2013;1901</mixed-citation>
      </ref>
      <ref id="CR58">
        <mixed-citation publication-type="other">The Lehigh University Benchmark (LUBM) (2014) <ext-link ext-link-type="uri" xlink:href="http://swat.cse.lehigh.edu/projects/lubm/">http://swat.cse.lehigh.edu/projects/lubm/</ext-link></mixed-citation>
      </ref>
      <ref id="CR59">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Tian</surname>
              <given-names>Y</given-names>
            </name>
            <name>
              <surname>Balmin</surname>
              <given-names>A</given-names>
            </name>
            <name>
              <surname>Corsten</surname>
              <given-names>SA</given-names>
            </name>
            <name>
              <surname>Tatikonda</surname>
              <given-names>S</given-names>
            </name>
            <name>
              <surname>McPherson</surname>
              <given-names>J</given-names>
            </name>
          </person-group>
          <article-title>From &#x201C;think like a vertex&#x201D; to &#x201C;think like a graph&#x201D;</article-title>
          <source>PVLDB</source>
          <year>2013</year>
          <volume>7</volume>
          <issue>3</issue>
          <fpage>193</fpage>
          <lpage>204</lpage>
        </element-citation>
      </ref>
      <ref id="CR60">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Valiant</surname>
              <given-names>LG</given-names>
            </name>
          </person-group>
          <article-title>A bridging model for parallel computation</article-title>
          <source>Commun ACM</source>
          <year>1990</year>
          <volume>33</volume>
          <issue>8</issue>
          <fpage>103</fpage>
          <lpage>111</lpage>
          <pub-id pub-id-type="doi">10.1145/79173.79181</pub-id>
        </element-citation>
      </ref>
      <ref id="CR61">
        <mixed-citation publication-type="other">Wang G, Xie W, Demers A, Gehrke J (2013) Asynchronous large-scale graph processing made easy. In: CIDR</mixed-citation>
      </ref>
      <ref id="CR62">
        <mixed-citation publication-type="other">Zaharia M, Chowdhury M, Franklin MJ, Shenker S, Stoica I (2010) Spark: cluster computing with working sets. In: HotCloud</mixed-citation>
      </ref>
      <ref id="CR63">
        <mixed-citation publication-type="other">Zeng K, Yang J, Wang H, Shao B, Wang Z (2013) A distributed graph engine for web scale RDF data. In: VLDB</mixed-citation>
      </ref>
      <ref id="CR64">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Zhou</surname>
              <given-names>R</given-names>
            </name>
            <name>
              <surname>Hansen</surname>
              <given-names>EA</given-names>
            </name>
          </person-group>
          <article-title>Breadth-first heuristic search</article-title>
          <source>Artif Intel</source>
          <year>2006</year>
          <volume>170</volume>
          <issue>4</issue>
          <fpage>385</fpage>
          <lpage>408</lpage>
          <pub-id pub-id-type="doi">10.1016/j.artint.2005.12.002</pub-id>
        </element-citation>
      </ref>
      <ref id="CR65">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Zou</surname>
              <given-names>L</given-names>
            </name>
            <name>
              <surname>Mo</surname>
              <given-names>J</given-names>
            </name>
            <name>
              <surname>Chen</surname>
              <given-names>L</given-names>
            </name>
            <name>
              <surname>&#xD6;zsu</surname>
              <given-names>MT</given-names>
            </name>
            <name>
              <surname>Zhao</surname>
              <given-names>D</given-names>
            </name>
          </person-group>
          <article-title>gStore: answering SPARQL queries via subgraph matching</article-title>
          <source>PVLDB</source>
          <year>2011</year>
          <volume>4</volume>
          <issue>8</issue>
          <fpage>482</fpage>
          <lpage>493</lpage>
        </element-citation>
      </ref>
    </ref-list>
  </back>
</article>
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article">
  <!--The publisher of this article does not allow downloading of the full text in XML form.-->
  <?properties manuscript?>
  <front>
    <journal-meta>
      <journal-id journal-id-type="nlm-journal-id">101523553</journal-id>
      <journal-id journal-id-type="pubmed-jr-id">37449</journal-id>
      <journal-id journal-id-type="nlm-ta">Proc ACM SIGMOD Int Conf Manag Data</journal-id>
      <journal-id journal-id-type="iso-abbrev">Proc ACM SIGMOD Int Conf Manag Data</journal-id>
      <journal-title-group>
        <journal-title>Proceedings / ACM-SIGMOD International Conference on Management of Data. ACM-Sigmod International Conference on Management of Data</journal-title>
      </journal-title-group>
      <issn pub-type="ppub">0730-8078</issn>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="pmid">27081215</article-id>
      <article-id pub-id-type="pmc">4829061</article-id>
      <article-id pub-id-type="doi">10.1145/2723372.2735369</article-id>
      <article-id pub-id-type="manuscript">NIHMS772325</article-id>
      <article-categories>
        <subj-group subj-group-type="heading">
          <subject>Article</subject>
        </subj-group>
      </article-categories>
      <title-group>
        <article-title>Ringo: Interactive Graph Analytics on Big-Memory Machines</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <name>
            <surname>Perez</surname>
            <given-names>Yonathan</given-names>
          </name>
          <email>yperez@cs.stanford.edu</email>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Sosi&#x10D;</surname>
            <given-names>Rok</given-names>
          </name>
          <email>rok@cs.stanford.edu</email>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Banerjee</surname>
            <given-names>Arijit</given-names>
          </name>
          <email>arijitb@cs.stanford.edu</email>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Puttagunta</surname>
            <given-names>Rohan</given-names>
          </name>
          <email>rohanp@cs.stanford.edu</email>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Raison</surname>
            <given-names>Martin</given-names>
          </name>
          <email>mraison@cs.stanford.edu</email>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Shah</surname>
            <given-names>Pararth</given-names>
          </name>
          <email>pararth@cs.stanford.edu</email>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Leskovec</surname>
            <given-names>Jure</given-names>
          </name>
          <email>jure@cs.stanford.edu</email>
        </contrib>
        <aff id="A1">Stanford University</aff>
      </contrib-group>
      <pub-date pub-type="nihms-submitted">
        <day>2</day>
        <month>4</month>
        <year>2016</year>
      </pub-date>
      <pub-date pub-type="ppub">
        <season>May-Jun</season>
        <year>2015</year>
      </pub-date>
      <pub-date pub-type="pmc-release">
        <day>12</day>
        <month>4</month>
        <year>2016</year>
      </pub-date>
      <volume>2015</volume>
      <fpage>1105</fpage>
      <lpage>1110</lpage>
      <!--elocation-id from pubmed: 10.1145/2723372.2735369-->
      <permissions>
        <license license-type="permissions-link">
          <license-p>Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others thanACM must be honored. Abstracting with credit is permitted. Request permissions from <email>permissions@acm.org</email>.</license-p>
        </license>
      </permissions>
      <abstract>
        <p id="P1">We present Ringo, a system for analysis of large graphs. Graphs provide a way to represent and analyze systems of interacting objects (people, proteins, webpages) with edges between the objects denoting interactions (friendships, physical interactions, links). Mining graphs provides valuable insights about individual objects as well as the relationships among them.</p>
        <p id="P2">In building Ringo, we take advantage of the fact that machines with large memory and many cores are widely available and also relatively affordable. This allows us to build an easy-to-use interactive high-performance graph analytics system. Graphs also need to be built from input data, which often resides in the form of relational tables. Thus, Ringo provides rich functionality for manipulating raw input data tables into various kinds of graphs. Furthermore, Ringo also provides over 200 graph analytics functions that can then be applied to constructed graphs.</p>
        <p id="P3">We show that a single big-memory machine provides a very attractive platform for performing analytics on all but the largest graphs as it offers excellent performance and ease of use as compared to alternative approaches. With Ringo, we also demonstrate how to integrate graph analytics with an iterative process of trial-and-error data exploration and rapid experimentation, common in data mining workloads.</p>
      </abstract>
      <kwd-group>
        <kwd>Graphs</kwd>
        <kwd>networks</kwd>
        <kwd>graph processing</kwd>
        <kwd>graph analytics</kwd>
      </kwd-group>
    </article-meta>
  </front>
</article>
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article">
  <!--The publisher of this article does not allow downloading of the full text in XML form.-->
  <?properties manuscript?>
  <front>
    <journal-meta>
      <journal-id journal-id-type="nlm-journal-id">101523553</journal-id>
      <journal-id journal-id-type="pubmed-jr-id">37449</journal-id>
      <journal-id journal-id-type="nlm-ta">Proc ACM SIGMOD Int Conf Manag Data</journal-id>
      <journal-id journal-id-type="iso-abbrev">Proc ACM SIGMOD Int Conf Manag Data</journal-id>
      <journal-title-group>
        <journal-title>Proceedings / ACM-SIGMOD International Conference on Management of Data. ACM-Sigmod International Conference on Management of Data</journal-title>
      </journal-title-group>
      <issn pub-type="ppub">0730-8078</issn>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="pmid">26819493</article-id>
      <article-id pub-id-type="pmc">4724804</article-id>
      <article-id pub-id-type="doi">10.1145/2723372.2742793</article-id>
      <article-id pub-id-type="manuscript">NIHMS728791</article-id>
      <article-categories>
        <subj-group subj-group-type="heading">
          <subject>Article</subject>
        </subj-group>
      </article-categories>
      <title-group>
        <article-title>REEF: Retainable Evaluator Execution Framework</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <name>
            <surname>Weimer</surname>
            <given-names>Markus</given-names>
          </name>
          <xref ref-type="aff" rid="A1">a</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Chen</surname>
            <given-names>Yingda</given-names>
          </name>
          <xref ref-type="aff" rid="A1">a</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Chun</surname>
            <given-names>Byung-Gon</given-names>
          </name>
          <xref ref-type="aff" rid="A3">c</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Condie</surname>
            <given-names>Tyson</given-names>
          </name>
          <xref ref-type="aff" rid="A2">b</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Curino</surname>
            <given-names>Carlo</given-names>
          </name>
          <xref ref-type="aff" rid="A1">a</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Douglas</surname>
            <given-names>Chris</given-names>
          </name>
          <xref ref-type="aff" rid="A1">a</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Lee</surname>
            <given-names>Yunseong</given-names>
          </name>
          <xref ref-type="aff" rid="A3">c</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Majestro</surname>
            <given-names>Tony</given-names>
          </name>
          <xref ref-type="aff" rid="A1">a</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Malkhi</surname>
            <given-names>Dahlia</given-names>
          </name>
          <xref ref-type="aff" rid="A6">f</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Matusevych</surname>
            <given-names>Sergiy</given-names>
          </name>
          <xref ref-type="aff" rid="A1">a</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Myers</surname>
            <given-names>Brandon</given-names>
          </name>
          <xref ref-type="aff" rid="A5">e</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Narayanamurthy</surname>
            <given-names>Shravan</given-names>
          </name>
          <xref ref-type="aff" rid="A1">a</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Ramakrishnan</surname>
            <given-names>Raghu</given-names>
          </name>
          <xref ref-type="aff" rid="A1">a</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Rao</surname>
            <given-names>Sriram</given-names>
          </name>
          <xref ref-type="aff" rid="A1">a</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Sears</surname>
            <given-names>Russell</given-names>
          </name>
          <xref ref-type="aff" rid="A4">d</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Sezgin</surname>
            <given-names>Beysim</given-names>
          </name>
          <xref ref-type="aff" rid="A1">a</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>Julia</given-names>
          </name>
          <xref ref-type="aff" rid="A1">a</xref>
        </contrib>
      </contrib-group>
      <aff id="A1"><label>a</label> Microsoft</aff>
      <aff id="A2"><label>b</label> UCLA</aff>
      <aff id="A3"><label>c</label> Seoul National University</aff>
      <aff id="A4"><label>d</label> Pure Storage</aff>
      <aff id="A5"><label>e</label> University of Washington</aff>
      <aff id="A6"><label>f</label> VMware</aff>
      <pub-date pub-type="nihms-submitted">
        <day>23</day>
        <month>12</month>
        <year>2015</year>
      </pub-date>
      <pub-date pub-type="ppub">
        <season>May-Jun</season>
        <year>2015</year>
      </pub-date>
      <pub-date pub-type="pmc-release">
        <day>25</day>
        <month>1</month>
        <year>2016</year>
      </pub-date>
      <volume>2015</volume>
      <fpage>1343</fpage>
      <lpage>1355</lpage>
      <!--elocation-id from pubmed: 10.1145/2723372.2742793-->
      <permissions>
        <license license-type="permission-link">
          <license-p>Request permissions from <email>permissions@acm.org</email>.</license-p>
        </license>
      </permissions>
      <abstract>
        <p id="P1">Resource Managers like Apache YARN have emerged as a critical layer in the cloud computing system stack, but the developer abstractions for leasing cluster resources and instantiating application logic are very low-level. This flexibility comes at a high cost in terms of developer effort, as each application must repeatedly tackle the same challenges (e.g., fault-tolerance, task scheduling and coordination) and re-implement common mechanisms (e.g., caching, bulk-data transfers). This paper presents REEF, a development framework that provides a control-plane for scheduling and coordinating task-level (data-plane) work on cluster resources obtained from a Resource Manager. REEF provides mechanisms that facilitate resource re-use for data caching, and state management abstractions that greatly ease the development of elastic data processing work-flows on cloud platforms that support a Resource Manager service. REEF is being used to develop several commercial offerings such as the Azure Stream Analytics service. Furthermore, we demonstrate REEF development of a distributed shell application, a machine learning algorithm, and a port of the CORFU [<xref rid="R4" ref-type="bibr">4</xref>] system. REEF is also currently an Apache Incubator project that has attracted contributors from several instititutions.<sup><xref ref-type="fn" rid="FN1">1</xref></sup></p>
      </abstract>
      <kwd-group>
        <kwd>Big Data</kwd>
        <kwd>Distributed Systems</kwd>
        <kwd>Database</kwd>
        <kwd>High Performance Computing</kwd>
        <kwd>Machine Learning</kwd>
      </kwd-group>
    </article-meta>
  </front>
</article>
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article">
  <!--The publisher of this article does not allow downloading of the full text in XML form.-->
  <?properties manuscript?>
  <front>
    <journal-meta>
      <journal-id journal-id-type="nlm-journal-id">101649640</journal-id>
      <journal-id journal-id-type="pubmed-jr-id">43465</journal-id>
      <journal-id journal-id-type="nlm-ta">Proc IEEE Int Conf Big Data</journal-id>
      <journal-title-group>
        <journal-title>Proceedings : ... IEEE International Conference on Big Data. IEEE International Conference on Big Data</journal-title>
      </journal-title-group>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="pmid">25866846</article-id>
      <article-id pub-id-type="pmc">4389765</article-id>
      <article-id pub-id-type="doi">10.1109/BigData.2014.7004226</article-id>
      <article-id pub-id-type="manuscript">NIHMS675777</article-id>
      <article-categories>
        <subj-group subj-group-type="heading">
          <subject>Article</subject>
        </subj-group>
      </article-categories>
      <title-group>
        <article-title>MMap: Fast Billion-Scale Graph Computation on a PC via Memory Mapping</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <name>
            <surname>Lin</surname>
            <given-names>Zhiyuan</given-names>
          </name>
          <email>zlin48@gatech.edu</email>
          <aff id="A1">Georgia Tech, Atlanta, Georgia</aff>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Kahng</surname>
            <given-names>Minsuk</given-names>
          </name>
          <email>kahng@gatech.edu</email>
          <aff id="A2">Georgia Tech, Atlanta, Georgia</aff>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Sabrin</surname>
            <given-names>Kaeser Md.</given-names>
          </name>
          <email>kmsabrin@gatech.edu</email>
          <aff id="A3">Georgia Tech, Atlanta, Georgia</aff>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Chau</surname>
            <given-names>Duen Horng (Polo)</given-names>
          </name>
          <email>polo@gatech.edu</email>
          <aff id="A4">Georgia Tech, Atlanta, Georgia</aff>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Lee</surname>
            <given-names>Ho</given-names>
          </name>
          <email>crtlife@kaist.ac.kr</email>
          <aff id="A5">KAIST, Daejeon, Republic of Korea</aff>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Kang</surname>
            <given-names>U</given-names>
          </name>
          <email>ukang@kaist.ac.kr</email>
          <aff id="A6">KAIST, Daejeon, Republic of Korea</aff>
        </contrib>
      </contrib-group>
      <pub-date pub-type="nihms-submitted">
        <day>31</day>
        <month>3</month>
        <year>2015</year>
      </pub-date>
      <pub-date pub-type="ppub">
        <month>10</month>
        <year>2014</year>
      </pub-date>
      <pub-date pub-type="pmc-release">
        <day>08</day>
        <month>4</month>
        <year>2015</year>
      </pub-date>
      <volume>2014</volume>
      <fpage>159</fpage>
      <lpage>164</lpage>
      <!--elocation-id from pubmed: 10.1109/BigData.2014.7004226-->
      <abstract>
        <p id="P1">Graph computation approaches such as GraphChi and TurboGraph recently demonstrated that a single PC can perform efficient computation on billion-node graphs. To achieve high speed and scalability, they often need sophisticated data structures and memory management strategies. We propose a minimalist approach that forgoes such requirements, by leveraging the fundamental <italic>memory mapping</italic> (MMap) capability found on operating systems. We contribute: (1) a new insight that MMap is a viable technique for creating fast and scalable graph algorithms that surpasses some of the best techniques; (2) the design and implementation of popular graph algorithms for billion-scale graphs with little code, thanks to memory mapping; (3) extensive experiments on real graphs, including the 6.6 billion edge YahooWeb graph, and show that this new approach is significantly faster or comparable to the highly-optimized methods (e.g., 9.5&#xD7; faster than GraphChi for computing PageRank on 1.47B edge Twitter graph). We believe our work provides a new direction in the design and development of scalable algorithms. Our packaged code is available at <ext-link ext-link-type="uri" xlink:href="http://poloclub.gatech.edu/mmap/">http://poloclub.gatech.edu/mmap/</ext-link>.</p>
      </abstract>
    </article-meta>
  </front>
</article>
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article">
  <?properties open_access?>
  <front>
    <journal-meta>
      <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
      <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
      <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
      <journal-id journal-id-type="hwp">bioinfo</journal-id>
      <journal-title-group>
        <journal-title>Bioinformatics</journal-title>
      </journal-title-group>
      <issn pub-type="ppub">1367-4803</issn>
      <issn pub-type="epub">1367-4811</issn>
      <publisher>
        <publisher-name>Oxford University Press</publisher-name>
      </publisher>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="pmid">25192741</article-id>
      <article-id pub-id-type="pmc">4271144</article-id>
      <article-id pub-id-type="doi">10.1093/bioinformatics/btu599</article-id>
      <article-id pub-id-type="publisher-id">btu599</article-id>
      <article-categories>
        <subj-group subj-group-type="heading">
          <subject>Applications Notes</subject>
          <subj-group subj-group-type="heading">
            <subject>Systems Biology</subject>
          </subj-group>
        </subj-group>
      </article-categories>
      <title-group>
        <article-title>BalestraWeb: efficient online evaluation of drug&#x2013;target interactions</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <name>
            <surname>Cobanoglu</surname>
            <given-names>Murat Can</given-names>
          </name>
          <xref ref-type="aff" rid="btu599-AFF1">
            <sup>1</sup>
          </xref>
          <xref ref-type="aff" rid="btu599-AFF1">
            <sup>2</sup>
          </xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Oltvai</surname>
            <given-names>Zolt&#xE1;n N.</given-names>
          </name>
          <xref ref-type="aff" rid="btu599-AFF1">
            <sup>1</sup>
          </xref>
          <xref ref-type="aff" rid="btu599-AFF1">
            <sup>3</sup>
          </xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Taylor</surname>
            <given-names>D. Lansing</given-names>
          </name>
          <xref ref-type="aff" rid="btu599-AFF1">
            <sup>1</sup>
          </xref>
          <xref ref-type="aff" rid="btu599-AFF1">
            <sup>2</sup>
          </xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Bahar</surname>
            <given-names>Ivet</given-names>
          </name>
          <xref ref-type="aff" rid="btu599-AFF1">
            <sup>1</sup>
          </xref>
          <xref ref-type="corresp" rid="btu599-COR1">*</xref>
        </contrib>
        <aff id="btu599-AFF1"><sup>1</sup>Department of Computational and Systems Biology, University of Pittsburgh, School of Medicine, Pittsburgh, PA, <sup>2</sup>The University of Pittsburgh Drug Discovery Institute, Pittsburgh, PA 15260 and <sup>3</sup>Department of Pathology, University of Pittsburgh, School of Medicine, Pittsburgh, PA 15213, USA</aff>
      </contrib-group>
      <author-notes>
        <corresp id="btu599-COR1">*To whom correspondence should be addressed.</corresp>
        <fn id="FN1">
          <p>Associate Editor: Jonathan Wren</p>
        </fn>
      </author-notes>
      <pub-date pub-type="ppub">
        <day>01</day>
        <month>1</month>
        <year>2015</year>
      </pub-date>
      <pub-date pub-type="epub">
        <day>05</day>
        <month>9</month>
        <year>2014</year>
      </pub-date>
      <pub-date pub-type="pmc-release">
        <day>05</day>
        <month>9</month>
        <year>2014</year>
      </pub-date>
      <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
      <volume>31</volume>
      <issue>1</issue>
      <fpage>131</fpage>
      <lpage>133</lpage>
      <history>
        <date date-type="received">
          <day>16</day>
          <month>4</month>
          <year>2014</year>
        </date>
        <date date-type="rev-recd">
          <day>3</day>
          <month>7</month>
          <year>2014</year>
        </date>
        <date date-type="accepted">
          <day>31</day>
          <month>8</month>
          <year>2014</year>
        </date>
      </history>
      <permissions>
        <copyright-statement>&#xA9; The Author 2014. Published by Oxford University Press.</copyright-statement>
        <copyright-year>2014</copyright-year>
        <license xlink:href="http://creativecommons.org/licenses/by-nc/4.0/" license-type="creative-commons">
          <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
        </license>
      </permissions>
      <abstract>
        <p><bold>Summary:</bold> BalestraWeb is an online server that allows users to instantly make predictions about the potential occurrence of interactions between any given drug&#x2013;target pair, or predict the most likely interaction partners of any drug or target listed in the DrugBank. It also permits users to identify most similar drugs or most similar targets based on their interaction patterns. Outputs help to develop hypotheses about drug repurposing as well as potential side effects.</p>
        <p><bold>Availability and implementation:</bold> BalestraWeb is accessible at <ext-link ext-link-type="uri" xlink:href="http://balestra.csb.pitt.edu/">http://balestra.csb.pitt.edu/</ext-link>. The tool is built using a probabilistic matrix factorization method and DrugBank v3, and the latent variable models are trained using the GraphLab collaborative filtering toolkit. The server is implemented using Python, Flask, NumPy and SciPy.</p>
        <p><bold>Contact:</bold>
<email>bahar@pitt.edu</email></p>
      </abstract>
      <counts>
        <page-count count="3"/>
      </counts>
    </article-meta>
  </front>
  <body>
    <sec>
      <title>1 INTRODUCTION</title>
      <p>Contemporary drug discovery faces important challenges: bringing a new molecular entity to the market is estimated to cost upward of 1.8 billion US$ (<xref rid="btu599-B12" ref-type="bibr">Paul <italic>et al.</italic>, 2010</xref>), and the rate of new drug discovery has steadily halved every 9 years for the past 60 years (<xref rid="btu599-B13" ref-type="bibr">Scannell <italic>et al.</italic>, 2012</xref>). One of the common suggestions brought forth to explain and remedy this trend is a paradigm shift in drug discovery efforts from high-affinity binding on a single target toward modulation of cellular network states through multiple interactions (<xref rid="btu599-B2" ref-type="bibr">Csermely <italic>et al.</italic>, 2005</xref>, <xref rid="btu599-B3" ref-type="bibr">2013</xref>; <xref rid="btu599-B4" ref-type="bibr">Hopkins, 2008</xref>; <xref rid="btu599-B5" ref-type="bibr">Keskin <italic>et al.</italic>, 2007</xref>; <xref rid="btu599-B8" ref-type="bibr">Korcsmaros <italic>et al.</italic>, 2007</xref>; <xref rid="btu599-B11" ref-type="bibr">Mencher and Wang, 2005</xref>; <xref rid="btu599-B14" ref-type="bibr">Zimmermann <italic>et al.</italic>, 2007</xref>). The development of computational methods that can efficiently assess potential new interactions for drug repurposing thus became an important goal in quantitative systems/network pharmacology research.</p>
      <p>We recently introduced a probabilistic matrix factorization (PMF) method that can be applied to known drug&#x2013;target interaction graphs for predicting new interactions (<xref rid="btu599-B1" ref-type="bibr">Cobanoglu <italic>et al.</italic>, 2013</xref>). Here, we introduce BalestraWeb, a Web server that has been developed for allowing users to efficiently obtain results from the PMF analysis, and assess the likelihood of interaction between any drug&#x2013;target pair.</p>
    </sec>
    <sec id="SEC2">
      <title>2 METHOD</title>
      <p>BalestraWeb is built by training a latent factor model, as described in our previous work (<xref rid="btu599-B1" ref-type="bibr">Cobanoglu <italic>et al.</italic>, 2013</xref>), on approved drugs and their interactions data from DrugBank v3 (<xref rid="btu599-B7" ref-type="bibr">Knox <italic>et al.</italic>, 2011</xref>). To build the latent factor model, we use the GraphLab collaborative filtering toolkit implementation (<xref rid="btu599-B10" ref-type="bibr">Low <italic>et al.</italic>, 2010</xref>). We mapped all the known names, brand names and synonyms of the drugs and targets to the relevant latent factor using a pre-computed hash table that allows constant time access and enables maximal efficiency.</p>
      <p>The server allows users to submit three types of queries: drug&#x2013;target interaction, drug&#x2013;drug similarity and target&#x2013;target similarity. In the former case (<xref ref-type="fig" rid="btu599-F1">Fig. 1</xref>), the input is mapped to the corresponding drug latent vector (LV) and target LV, and the dot product of these vectors yields a score for the probabilistic occurrence of the queried drug&#x2013;target interaction. Alternatively, the user can enter a single type of input, either a drug or a target. If a single drug is entered, the server retrieves the LV for that drug and screens it against the entire set of LVs corresponding to all targets, so as to identify known and newly predicted targets. Drug&#x2013;drug and target&#x2013;target similarity queries provide information on drugs (or targets) similar to the query drug (or target) based on the cosine similarity of their LVs.
<fig id="btu599-F1" position="float"><label>Fig. 1.</label><caption><p>BalestraWeb architecture and underlying methodology. The user input (<italic>lower left</italic>) is mapped onto the latent factor vector(s) <italic>u<sub>i</sub>v<sub>j</sub></italic> (for targets), learned by minimizing squared error regularized by Frobenius norm (see equation at top left). The output (right) contains a score R representative of predicted interaction confidence along with a graphical representation of the close neighborhood of the query drug (Sunitinib) and/or query target (SCN5A) in the drug-target association network, along with a table of known and predicted interactions. Similar features hold for drug-drug and target-target similarity searches and outputs</p></caption><graphic xlink:href="btu599f1p"/></fig></p>
      <p>The output is an interactive graph (that can be downloaded in JSON format) and a table displaying both the known drug&#x2013;target interactions for the query drug (target) and the top N predicted targets (drugs), rank-ordered by their score. Users can select to view a second layer of interactions beyond the immediate neighbors of the query drug/target in the bipartite network of drugs and targets. The resulting subnet of interactions thus provides a more complete picture of the investigated drug/target in the context of the interactions of their known targets/drugs.</p>
      <p>In addition to providing information on the distribution of scores in general in the tutorial, we provide query-specific histograms in the output files: the distribution of the predicted confidence score (for each member of the drug&#x2013;target pairs) or the histogram of cosine similarities (for each member of the drug&#x2013;drug or target&#x2013;target pairs). These histograms facilitate the interpretation of the specific score released for the query pair in the context of the complete distribution of scores for the investigated drug/target, and help make a better assessment of the significance of the outputted score.</p>
    </sec>
    <sec id="SEC3">
      <title>3 DISTINCTIVE FEATURES</title>
      <p>There are three important distinguishing features of BalestraWeb: its ability to provide information on the likelihood of interaction between any drug and any target; its reliance on interaction profiles instead of chemical similarity; and its ability to compare drugs with drugs and targets with targets. The widely used similarity ensemble approach (SEA) (<xref rid="btu599-B6" ref-type="bibr">Keiser <italic>et al.</italic>, 2007</xref>) uses ligand similarity to identify new ligands based on chemical similarity. STITCH (<xref rid="btu599-B9" ref-type="bibr">Kuhn <italic>et al.</italic>, 2014</xref>) is an extensive repository of protein and chemicals (1.07 billion interactions), including predictions based on chemical similarities of compounds. However, the interactions predicted by BalestraWeb are not based on a particular chemical or genomic similarity method, but on the assessment of comparable interaction patterns, and as such they differ from, or complement, those predicted by SEA or listed by STITCH.</p>
    </sec>
    <sec>
      <title>4 CONCLUSION</title>
      <p>BalestraWeb provides users the ability to predict the most likely interaction partners of any drug or target beyond those known and compiled in the DrugBank. The technology used to build the Web server scales linearly with the number of drugs or targets and is therefore easily scalable to larger datasets as they become available. Our plan is to regularly update the underlying engine and optimized parameters by using the newly released data. The modular architecture of the software allows us to update the Web server to reflect changes as new data become available. Free, fast and easy-to-use BalestraWeb enables researchers to help eliminate improbable drug&#x2013;target interactions and efficiently focus their limited resources on selected drugs.</p>
      <p><italic>Funding</italic>: Support from the <funding-source>NIH</funding-source> (<award-id>U19 AI068021</award-id> and <award-id>PO1</award-id>
<award-id>DK096990</award-id>) is gratefully acknowledged by I.B.</p>
      <p><italic>Conflict of interest:</italic> none declared.</p>
    </sec>
  </body>
  <back>
    <ref-list>
      <title>REFERENCES</title>
      <ref id="btu599-B1">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Cobanoglu</surname>
              <given-names>MC</given-names>
            </name>
            <etal/>
          </person-group>
          <article-title>Predicting drug-target interactions using probabilistic matrix factorization</article-title>
          <source>J. Chem. Inf. Model.</source>
          <year>2013</year>
          <volume>53</volume>
          <fpage>3399</fpage>
          <lpage>3409</lpage>
          <pub-id pub-id-type="pmid">24289468</pub-id>
        </element-citation>
      </ref>
      <ref id="btu599-B2">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Csermely</surname>
              <given-names>P</given-names>
            </name>
            <etal/>
          </person-group>
          <article-title>The efficiency of multi-target drugs: the network approach might help drug design</article-title>
          <source>Trends Pharmacol. Sci.</source>
          <year>2005</year>
          <volume>26</volume>
          <fpage>178</fpage>
          <lpage>182</lpage>
          <pub-id pub-id-type="pmid">15808341</pub-id>
        </element-citation>
      </ref>
      <ref id="btu599-B3">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Csermely</surname>
              <given-names>P</given-names>
            </name>
            <etal/>
          </person-group>
          <article-title>Structure and dynamics of molecular networks: a novel paradigm of drug discovery: a comprehensive review</article-title>
          <source>Pharmacol. Ther.</source>
          <year>2013</year>
          <volume>138</volume>
          <fpage>333</fpage>
          <lpage>408</lpage>
          <pub-id pub-id-type="pmid">23384594</pub-id>
        </element-citation>
      </ref>
      <ref id="btu599-B4">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Hopkins</surname>
              <given-names>AL</given-names>
            </name>
          </person-group>
          <article-title>Network pharmacology: the next paradigm in drug discovery</article-title>
          <source>Nat. Chem. Biol.</source>
          <year>2008</year>
          <volume>4</volume>
          <fpage>682</fpage>
          <lpage>690</lpage>
          <pub-id pub-id-type="pmid">18936753</pub-id>
        </element-citation>
      </ref>
      <ref id="btu599-B5">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Keskin</surname>
              <given-names>O</given-names>
            </name>
            <etal/>
          </person-group>
          <article-title>Towards drugs targeting multiple proteins in a systems biology approach</article-title>
          <source>Curr. Top. Med. Chem.</source>
          <year>2007</year>
          <volume>7</volume>
          <fpage>943</fpage>
          <lpage>951</lpage>
          <pub-id pub-id-type="pmid">17508925</pub-id>
        </element-citation>
      </ref>
      <ref id="btu599-B6">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Keiser</surname>
              <given-names>MJ</given-names>
            </name>
            <etal/>
          </person-group>
          <article-title>Relating protein pharmacology by ligand chemistry</article-title>
          <source>Nat. Biotechnol.</source>
          <year>2007</year>
          <volume>25</volume>
          <fpage>197</fpage>
          <lpage>206</lpage>
          <pub-id pub-id-type="pmid">17287757</pub-id>
        </element-citation>
      </ref>
      <ref id="btu599-B7">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Knox</surname>
              <given-names>C</given-names>
            </name>
            <etal/>
          </person-group>
          <article-title>DrugBank 3.0: a comprehensive resource for &#x2018;omics&#x2019; research on drugs</article-title>
          <source>Nucleic Acids Res.</source>
          <year>2011</year>
          <volume>39</volume>
          <fpage>D1035</fpage>
          <lpage>D1041</lpage>
          <pub-id pub-id-type="pmid">21059682</pub-id>
        </element-citation>
      </ref>
      <ref id="btu599-B8">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Korcsmaros</surname>
              <given-names>T</given-names>
            </name>
            <etal/>
          </person-group>
          <article-title>How to design multi-target drugs: target search options in cellular networks</article-title>
          <source>Discovery</source>
          <year>2007</year>
          <volume>2</volume>
          <fpage>1</fpage>
          <lpage>10</lpage>
        </element-citation>
      </ref>
      <ref id="btu599-B9">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Kuhn</surname>
              <given-names>M</given-names>
            </name>
            <etal/>
          </person-group>
          <article-title>STITCH 4: integration of protein-chemical interactions with user data</article-title>
          <source>Nucleic. Acids. Res.</source>
          <year>2014</year>
          <volume>42</volume>
          <fpage>D401</fpage>
          <lpage>D407</lpage>
          <pub-id pub-id-type="pmid">24293645</pub-id>
        </element-citation>
      </ref>
      <ref id="btu599-B10">
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name>
              <surname>Low</surname>
              <given-names>Y</given-names>
            </name>
            <etal/>
          </person-group>
          <article-title>Graphlab: a new framework for parallel machine learning</article-title>
          <source>Conference on Uncertainty in Artificial Intelligence</source>
          <year>2010</year>
          <publisher-loc>Catalina Island, CA</publisher-loc>
        </element-citation>
      </ref>
      <ref id="btu599-B11">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Mencher</surname>
              <given-names>SK</given-names>
            </name>
            <name>
              <surname>Wang</surname>
              <given-names>LG</given-names>
            </name>
          </person-group>
          <article-title>Promiscuous drugs compared to selective drugs (promiscuity can be a virtue)</article-title>
          <source>BMC Clin. Pharmacol.</source>
          <year>2005</year>
          <volume>5</volume>
          <fpage>3</fpage>
          <pub-id pub-id-type="pmid">15854222</pub-id>
        </element-citation>
      </ref>
      <ref id="btu599-B12">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Paul</surname>
              <given-names>SM</given-names>
            </name>
            <etal/>
          </person-group>
          <article-title>How to improve R&amp;D productivity: the pharmaceutical industry's grand challenge</article-title>
          <source>Nat. Rev. Drug Discov.</source>
          <year>2010</year>
          <volume>9</volume>
          <fpage>203</fpage>
          <lpage>214</lpage>
          <pub-id pub-id-type="pmid">20168317</pub-id>
        </element-citation>
      </ref>
      <ref id="btu599-B13">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Scannell</surname>
              <given-names>JW</given-names>
            </name>
            <etal/>
          </person-group>
          <article-title>Diagnosing the decline in pharmaceutical R&amp;D efficiency</article-title>
          <source>Na.t Rev. Drug Discov.</source>
          <year>2012</year>
          <volume>11</volume>
          <fpage>191</fpage>
          <lpage>200</lpage>
        </element-citation>
      </ref>
      <ref id="btu599-B14">
        <element-citation publication-type="journal">
          <person-group person-group-type="author">
            <name>
              <surname>Zimmermann</surname>
              <given-names>GR</given-names>
            </name>
            <etal/>
          </person-group>
          <article-title>Multi-target therapeutics: when the whole is greater than the sum of the parts</article-title>
          <source>Drug Discov. Today</source>
          <year>2007</year>
          <volume>12</volume>
          <fpage>34</fpage>
          <lpage>42</lpage>
          <pub-id pub-id-type="pmid">17198971</pub-id>
        </element-citation>
      </ref>
    </ref-list>
  </back>
</article>
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article">
  <!--The publisher of this article does not allow downloading of the full text in XML form.-->
  <front>
    <journal-meta>
      <journal-id journal-id-type="nlm-ta">Yearb Med Inform</journal-id>
      <journal-id journal-id-type="publisher-id">YMI</journal-id>
      <journal-title-group>
        <journal-title>Yearbook of Medical Informatics</journal-title>
      </journal-title-group>
      <issn pub-type="ppub">0943-4747</issn>
      <issn pub-type="epub">2364-0502</issn>
      <publisher>
        <publisher-name>Schattauer GmbH</publisher-name>
      </publisher>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="pmid">25123720</article-id>
      <article-id pub-id-type="pmc">4287098</article-id>
      <article-id pub-id-type="doi">10.15265/IY-2014-0018</article-id>
      <article-categories>
        <subj-group subj-group-type="heading">
          <subject>Working Group Contributions</subject>
        </subj-group>
      </article-categories>
      <title-group>
        <article-title>Technical Challenges for Big Data in Biomedicine and Health: Data Sources,
Infrastructure, and Analytics</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author" corresp="yes">
          <name>
            <surname>Peek</surname>
            <given-names>N.</given-names>
          </name>
          <xref ref-type="aff" rid="aff001">
            <sup>1</sup>
          </xref>
          <xref ref-type="aff" rid="aff002">
            <sup>2</sup>
          </xref>
          <xref ref-type="corresp" rid="cor1"/>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Holmes</surname>
            <given-names>J. H.</given-names>
          </name>
          <xref ref-type="aff" rid="aff003">
            <sup>3</sup>
          </xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Sun</surname>
            <given-names>J.</given-names>
          </name>
          <xref ref-type="aff" rid="aff004">
            <sup>4</sup>
          </xref>
        </contrib>
      </contrib-group>
      <aff id="aff001"><label>1</label> Dept. of Medical Informatics, Academic Medical Center,
<institution>University of Amsterdam</institution>, <addr-line>The Netherlands</addr-line></aff>
      <aff id="aff002"><label>2</label> Centre for Health Informatics, Institute of Population Health,
<institution>University of Manchester</institution>, <addr-line>Manchester, UK</addr-line></aff>
      <aff id="aff003"><label>3</label> Center for Clinical Epidemiology and Biostatistics,
<institution>University of Pennsylvania Perelman School of Medicine</institution>,
<addr-line>Philadelphia, PA, USA</addr-line></aff>
      <aff id="aff004"><label>4</label><institution>College of Computing, Georgia Institute of Technology</institution>,
<addr-line>Atlanta, GA, USA</addr-line></aff>
      <author-notes>
        <corresp>Correspondence to:</corresp>
        <corresp id="cor1">Niels Peek, Centre for Health Informatics, The University of Manchester, Vaughan
House, Portsmouth Street, Manchester M13 9GB, United Kingdom,
<email>niels.peek@manchester.ac.uk</email></corresp>
      </author-notes>
      <pub-date pub-type="epub">
        <day>15</day>
        <month>8</month>
        <year>2014</year>
      </pub-date>
      <pub-date pub-type="collection">
        <year>2014</year>
      </pub-date>
      <volume>9</volume>
      <issue>1</issue>
      <fpage>42</fpage>
      <lpage>47</lpage>
      <permissions>
        <copyright-statement>&#xA9; IMIA and Schattauer GmbH 2014</copyright-statement>
        <copyright-year>2014</copyright-year>
      </permissions>
      <abstract>
        <title>Summary</title>
        <sec>
          <title>Objectives</title>
          <p>To review technical and methodological challenges for big data research in biomedicine and
health.</p>
        </sec>
        <sec>
          <title>Methods</title>
          <p>We discuss sources of big datasets, survey infrastructures for big data storage and big data
processing, and describe the main challenges that arise when analyzing big data.</p>
        </sec>
        <sec>
          <title>Results</title>
          <p>The life and biomedical sciences are massively contributing to the big data revolution through
secondary use of data that were collected during routine care and through new data sources such as
social media. Efficient processing of big datasets is typically achieved by distributing computation
over a cluster of computers. Data analysts should be aware of pitfalls related to big data such as
bias in routine care data and the risk of false-positive findings in high-dimensional datasets.</p>
        </sec>
        <sec>
          <title>Conclusions</title>
          <p>The major challenge for the near future is to transform analytical methods that are used in the
biomedical and health domain, to fit the distributed storage and processing model that is required
to handle big data, while ensuring confidentiality of the data being analyzed.</p>
        </sec>
      </abstract>
      <kwd-group>
        <title>Keywords</title>
        <kwd>Big Data</kwd>
        <kwd>electronic health records</kwd>
        <kwd>distributed computing</kwd>
        <kwd>statistical analysis</kwd>
      </kwd-group>
      <counts>
        <fig-count count="0"/>
        <table-count count="0"/>
        <equation-count count="0"/>
        <ref-count count="32"/>
        <page-count count="6"/>
      </counts>
    </article-meta>
  </front>
</article>
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article">
  <!--The publisher of this article does not allow downloading of the full text in XML form.-->
  <?properties manuscript?>
  <front>
    <journal-meta>
      <journal-id journal-id-type="nlm-journal-id">101633095</journal-id>
      <journal-id journal-id-type="pubmed-jr-id">42623</journal-id>
      <journal-id journal-id-type="nlm-ta">Natl Sci Rev</journal-id>
      <journal-id journal-id-type="iso-abbrev">Natl Sci Rev</journal-id>
      <journal-title-group>
        <journal-title>National science review</journal-title>
      </journal-title-group>
      <issn pub-type="ppub">2095-5138</issn>
      <issn pub-type="epub">2053-714X</issn>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="pmid">25419469</article-id>
      <article-id pub-id-type="pmc">4236847</article-id>
      <article-id pub-id-type="doi">10.1093/nsr/nwt032</article-id>
      <article-id pub-id-type="manuscript">NIHMS585110</article-id>
      <article-categories>
        <subj-group subj-group-type="heading">
          <subject>Article</subject>
        </subj-group>
      </article-categories>
      <title-group>
        <article-title>Challenges of Big Data Analysis</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <name>
            <surname>Fan</surname>
            <given-names>Jianqing</given-names>
          </name>
          <xref ref-type="aff" rid="A1">*</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Han</surname>
            <given-names>Fang</given-names>
          </name>
          <xref ref-type="aff" rid="A2">&#x2020;</xref>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>Han</given-names>
          </name>
          <xref ref-type="aff" rid="A3">&#x2021;</xref>
        </contrib>
      </contrib-group>
      <aff id="A1"><label>*</label>Department of Operations Research and Financial Engineering, Princeton University, Princeton, NJ 08544, USA; <email>jqfan@princeton.edu</email>.</aff>
      <aff id="A2"><label>&#x2020;</label>Department of Biostatistics, Johns Hopkins University, Baltimore, MD 21205, USA; <email>fhan@jhsph.edu</email>.</aff>
      <aff id="A3"><label>&#x2021;</label>Department of Operations Research and Financial Engineering, Princeton University, Princeton, NJ 08544, USA; <email>hanliu@princeton.edu</email>.</aff>
      <pub-date pub-type="nihms-submitted">
        <day>4</day>
        <month>6</month>
        <year>2014</year>
      </pub-date>
      <pub-date pub-type="ppub">
        <month>6</month>
        <year>2014</year>
      </pub-date>
      <pub-date pub-type="pmc-release">
        <day>01</day>
        <month>12</month>
        <year>2014</year>
      </pub-date>
      <volume>1</volume>
      <issue>2</issue>
      <fpage>293</fpage>
      <lpage>314</lpage>
      <!--elocation-id from pubmed: 10.1093/nsr/nwt032-->
      <abstract>
        <p id="P1">Big Data bring new opportunities to modern society and challenges to data scientists. On one hand, Big Data hold great promises for discovering subtle population patterns and heterogeneities that are not possible with small-scale data. On the other hand, the massive sample size and high dimensionality of Big Data introduce unique computational and statistical challenges, including scalability and storage bottleneck, noise accumulation, spurious correlation, incidental endogeneity, and measurement errors. These challenges are distinguished and require new computational and statistical paradigm. This article gives overviews on the salient features of Big Data and how these features impact on paradigm change on statistical and computational methods as well as computing architectures. We also provide various new perspectives on the Big Data analysis and computation. In particular, we emphasize on the viability of the sparsest solution in high-confidence set and point out that exogeneous assumptions in most statistical methods for Big Data can not be validated due to incidental endogeneity. They can lead to wrong statistical inferences and consequently wrong scientific conclusions.</p>
      </abstract>
      <kwd-group>
        <kwd>Big Data</kwd>
        <kwd>massive data</kwd>
        <kwd>high dimensional data</kwd>
        <kwd>noise accumulation</kwd>
        <kwd>spurious correlation</kwd>
        <kwd>incidental endogeneity</kwd>
        <kwd>data storage</kwd>
        <kwd>scalability</kwd>
        <kwd>massively parallel data processing</kwd>
        <kwd>large-scale optimization</kwd>
        <kwd>random projection</kwd>
      </kwd-group>
    </article-meta>
  </front>
</article>
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article" xml:lang="en">
  <?properties open_access?>
  <front>
    <journal-meta>
      <journal-id journal-id-type="nlm-ta">Gigascience</journal-id>
      <journal-id journal-id-type="iso-abbrev">Gigascience</journal-id>
      <journal-title-group>
        <journal-title>GigaScience</journal-title>
      </journal-title-group>
      <issn pub-type="epub">2047-217X</issn>
      <publisher>
        <publisher-name>BioMed Central</publisher-name>
      </publisher>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="pmid">24843788</article-id>
      <article-id pub-id-type="pmc">4006453</article-id>
      <article-id pub-id-type="publisher-id">2047-217X-3-5</article-id>
      <article-id pub-id-type="doi">10.1186/2047-217X-3-5</article-id>
      <article-categories>
        <subj-group subj-group-type="heading">
          <subject>Research</subject>
        </subj-group>
      </article-categories>
      <title-group>
        <article-title>Think globally and solve locally: secondary memory-based network learning for automated multi-species function prediction</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author" equal-contrib="yes" id="A1">
          <name>
            <surname>Mesiti</surname>
            <given-names>Marco</given-names>
          </name>
          <xref ref-type="aff" rid="I1">1</xref>
          <email>mesiti@di.unimi.it</email>
        </contrib>
        <contrib contrib-type="author" equal-contrib="yes" id="A2">
          <name>
            <surname>Re</surname>
            <given-names>Matteo</given-names>
          </name>
          <xref ref-type="aff" rid="I1">1</xref>
          <email>matteo.re@unimi.it</email>
        </contrib>
        <contrib contrib-type="author" corresp="yes" equal-contrib="yes" id="A3">
          <name>
            <surname>Valentini</surname>
            <given-names>Giorgio</given-names>
          </name>
          <xref ref-type="aff" rid="I1">1</xref>
          <email>valentini@di.unimi.it</email>
        </contrib>
      </contrib-group>
      <aff id="I1"><label>1</label>AnacletoLab - Department of Computer Science, University of Milano, Via Comelico 39/41, 20135 Milano, Italy</aff>
      <pub-date pub-type="collection">
        <year>2014</year>
      </pub-date>
      <pub-date pub-type="epub">
        <day>23</day>
        <month>4</month>
        <year>2014</year>
      </pub-date>
      <volume>3</volume>
      <fpage>5</fpage>
      <lpage>5</lpage>
      <history>
        <date date-type="received">
          <day>4</day>
          <month>12</month>
          <year>2013</year>
        </date>
        <date date-type="accepted">
          <day>1</day>
          <month>4</month>
          <year>2014</year>
        </date>
      </history>
      <permissions>
        <copyright-statement>Copyright &#xA9; 2014 Mesiti et al.; licensee BioMed Central Ltd.</copyright-statement>
        <copyright-year>2014</copyright-year>
        <copyright-holder>Mesiti et al.; licensee BioMed Central Ltd.</copyright-holder>
        <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
          <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
        </license>
      </permissions>
      <self-uri xlink:href="http://www.gigasciencejournal.com/content/3/1/5"/>
      <abstract>
        <sec>
          <title>Background</title>
          <p>Network-based learning algorithms for automated function prediction (AFP) are negatively affected by the limited coverage of experimental data and limited <italic>a priori</italic> known functional annotations. As a consequence their application to model organisms is often restricted to well characterized biological processes and pathways, and their effectiveness with poorly annotated species is relatively limited. A possible solution to this problem might consist in the construction of big networks including multiple species, but this in turn poses challenging computational problems, due to the scalability limitations of existing algorithms and the main memory requirements induced by the construction of big networks. Distributed computation or the usage of big computers could in principle respond to these issues, but raises further algorithmic problems and require resources not satisfiable with simple off-the-shelf computers.</p>
        </sec>
        <sec>
          <title>Results</title>
          <p>We propose a novel framework for scalable network-based learning of multi-species protein functions based on both a local implementation of existing algorithms and the adoption of innovative technologies: we solve &#x201C;locally&#x201D; the AFP problem, by designing &#x201C;vertex-centric&#x201D; implementations of network-based algorithms, but we do not give up thinking &#x201C;globally&#x201D; by exploiting the overall topology of the network. This is made possible by the adoption of secondary memory-based technologies that allow the efficient use of the large memory available on disks, thus overcoming the main memory limitations of modern off-the-shelf computers. This approach has been applied to the analysis of a large multi-species network including more than 300 species of bacteria and to a network with more than 200,000 proteins belonging to 13 Eukaryotic species. To our knowledge this is the first work where secondary-memory based network analysis has been applied to multi-species function prediction using biological networks with hundreds of thousands of proteins.</p>
        </sec>
        <sec>
          <title>Conclusions</title>
          <p>The combination of these algorithmic and technological approaches makes feasible the analysis of large multi-species networks using ordinary computers with limited speed and primary memory, and in perspective could enable the analysis of huge networks (e.g. the whole proteomes available in SwissProt), using well-equipped stand-alone machines.</p>
        </sec>
      </abstract>
      <kwd-group>
        <kwd>Biomolecular networks</kwd>
        <kwd>Big data analysis</kwd>
        <kwd>Network-based learning</kwd>
      </kwd-group>
    </article-meta>
  </front>
  <body>
    <sec>
      <title>Background</title>
      <p>In recent years many efforts have been devoted to build automated tools for large scale automated function prediction of proteins (AFP) exploiting the knowledge generated by high throughput biotechnologies [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B2">2</xref>]. As highlighted by a recent international challenge for the critical assessment of automated function prediction [<xref ref-type="bibr" rid="B3">3</xref>], scalability and heterogeneity of the available data represent two of the main challenges posed by AFP. Indeed on the one hand no single experimental method can fully characterize the multiplicity of the protein functions, and on the other hand the huge amount of data to be processed poses serious computational problems. The complexity of the problem is furthermore exacerbated by the different level of the functional annotation coverage in different organisms, thus making very difficult the effective transfer of the available functional knowledge from one organism to another.</p>
      <p>Computational automated function prediction approaches can be useful for the integration of diverse types of data coming from multiple, often unrelated, proteomic and genomic pipelines. A recent example is represented by the Integrative multi-species prediction (IMP) web server [<xref ref-type="bibr" rid="B4">4</xref>] which integrates prior knowledge and data collections from multiple organisms for the generation of novel functional working hypotheses used in experimental follow-up. Despite its undoubted usefulness, IMP actually covers only seven model organisms, preventing its application to the prediction of the functions of proteins belonging to the proteomes of poorly annotated organisms.</p>
      <p>Another popular approach for gene functional annotation transfer between species relies on the availability of a collection of orthology relationships across interspecies proteins, and on the usage of an evolutionary relationships network as a suitable medium for transferring functional annotations to the proteins of poorly annotated organisms [<xref ref-type="bibr" rid="B5">5</xref>]. Even if orthology is an evolutionary concept, rather than a functional one, it can be used to link functionally equivalent genes across genomes and enables the functional inference of unknown proteins using one or more functionally characterized orthologs in other species [<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B7">7</xref>].</p>
      <p>As noticed in [<xref ref-type="bibr" rid="B4">4</xref>], the accuracy of machine-learning algorithms for AFP tasks is negatively affected by the sparse coverage of experimental data and by the limited availability of prior functional knowledge. Consequently, these methods are often applied only to biological processes and pathways that are already well characterized for an organism. The construction of large scale multi species networks can be a solution to this problem. Following this approach, network based learning algorithms might benefit of the availability of a priori functional knowledge coming from well annotated species to effectively perform a functional transfer to the proteins of poorly annotated organisms.</p>
      <p>Unfortunately this solution is only apparently simple, since the application of classical graph-based algorithms such as the ones based on random walks [<xref ref-type="bibr" rid="B8">8</xref>] or label propagation methods [<xref ref-type="bibr" rid="B9">9</xref>,<xref ref-type="bibr" rid="B10">10</xref>] are often unfeasible with large multi-species networks, especially when only single off-the-shelf machines are available. These approaches, indeed, usually rely on an in-memory adjacency matrix representation of the graph network, scale poorly with the size of the graph [<xref ref-type="bibr" rid="B11">11</xref>], and may have time complexity that becomes quickly prohibitive. Performance optimization is usually realized by adopting an adjacency-list representation of the graph to take its sparsity into account, or by using parallel strategies for matrix multiplication [<xref ref-type="bibr" rid="B12">12</xref>]. However, when the size of the graph becomes so high that is not possible to maintain it entirely in primary memory, either approaches based on parallel distributed computation [<xref ref-type="bibr" rid="B13">13</xref>-<xref ref-type="bibr" rid="B15">15</xref>], or secondary memory-based computation [<xref ref-type="bibr" rid="B16">16</xref>-<xref ref-type="bibr" rid="B18">18</xref>] can be considered. With distributed computation techniques, the graph is spread on different machines and the results are finally collected. However, as outlined in [<xref ref-type="bibr" rid="B16">16</xref>], a key issue of these approaches is the need to identify a cut of the graph in order to minimize the communication overhead among machines and their synchronization activities. With secondary memory-based computation, the graph is stored on the disk of a single machine and only limited portions of the graph are loaded in primary memory for computation. In this way, it is possible to overcome the lack of enough primary memory. The use of smart strategies for caching the portions of graph needed for computation [<xref ref-type="bibr" rid="B19">19</xref>], the minimization of the number of accesses to secondary memory [<xref ref-type="bibr" rid="B20">20</xref>], and the usage of compressed data structures for maintaining the graph in primary memory [<xref ref-type="bibr" rid="B21">21</xref>] are the main challenges for making the management of large graph networks in off-the-shelf machines comparable to distributed approaches.</p>
      <p>In this work we propose a novel framework for scalable semi-supervised network-based learning of multi-species protein functions: on the one hand we adopt a &#x201C;local learning strategy&#x201D; to implement classical graph-based algorithms for protein function prediction, and on the other hand we apply secondary memory-based technologies to exploit the large disks available in ordinary off-the-shelf computers. The combination of these algorithmic and technological approaches makes feasible the analysis of large multi-species networks in ordinary computers with limited speed and primary memory and in perspective could enable the analysis of huge networks (e.g. the whole proteomes available in SwissProt), using well-equipped stand-alone machines.</p>
      <p>Only very recently a paper has been devoted to the application of graph database technologies in bioinformatics [<xref ref-type="bibr" rid="B22">22</xref>], and to our knowledge this is the first work where secondary-memory based network analysis has been applied to multi-species function prediction using big biological networks with hundreds of thousands of proteins.</p>
      <p>This paper is organized as follows. In the next section we introduce our proposed approach based on the local implementation of network-based algorithms and secondary memory-based computation for the multi-species AFP problem. In particular we discuss the characteristics of <italic>Neo4j</italic>, a database technology for graph querying and processing, and <italic>GraphChi</italic>, a disk-based system for graph processing. Then, we show their application to a multi-species network involving proteins of about 300 bacteria species, and to a network including 13 species of Eukaryotes with more than 200.000 proteins, using off-the-shelf notebook and desktop computers.</p>
    </sec>
    <sec sec-type="methods">
      <title>Methods</title>
      <p>Our approach to big-graph analysis for AFP leverages on both a novel computational model for network analysis and on novel technologies for fast and efficient secondary memory-based computation. More precisely we adopt at the same time two strategies for scalable network-based learning of protein function: </p>
      <p>1. <italic>Local Implementation</italic> of network-based algorithms. To solve the overall AFP problem we adopt a local learning strategy, according to a &#x201C;vertex-centric&#x201D; computational model.</p>
      <p>2. <italic>Secondary memory-based computation</italic>. We exploit novel technologies for fast and efficient secondary-memory access: the overall graph is maintained on disk and only small parts of it are loaded each time into primary memory.</p>
      <p>It is worth noting that we do not propose novel algorithms, but simply their &#x201C;local implementation&#x201D;, according to a vertex-centric programming model, necessary for secondary memory-based computation [<xref ref-type="bibr" rid="B14">14</xref>]. Indeed the strength of the proposed approach consists precisely in coupling a &#x201C;local&#x201D; vertex-centric implementation of network-based algorithms with technologies based on secondary memory, to make efficient the local access to graphs stored on disk, thus also allowing the processing of big biological networks when limited RAM memory is available.</p>
      <sec>
        <title>Local implementation of network-based algorithms</title>
        <p>The most effective network-based algorithms for AFP learn by exploiting the overall topology of the networks [<xref ref-type="bibr" rid="B23">23</xref>-<xref ref-type="bibr" rid="B25">25</xref>], and their implementation usually requires to process in primary memory a large part or the overall underlying graph. The main drawback of this implementation is that big networks cannot be entirely loaded into primary memory using off-the-shelf machines.</p>
        <p>We aim at providing local implementations of &#x201C;global&#x201D; network algorithms by iteratively processing only one vertex and its incident edges at a time. In other words we do not reject to think &#x201C;globally&#x201D; by exploiting the overall topology of the network, but at the same time we solve &#x201C;locally&#x201D; by designing implementations of these algorithms through a vertex-centric programming model [<xref ref-type="bibr" rid="B14">14</xref>,<xref ref-type="bibr" rid="B26">26</xref>].</p>
        <p>As an example, we consider the local implementation of the &#x201C;vanilla&#x201D; random walk (<italic>RW</italic>) algorithm [<xref ref-type="bibr" rid="B8">8</xref>], a popular network-based method just successfully applied to AFP [<xref ref-type="bibr" rid="B24">24</xref>]. It is worth noting that the <italic>RW</italic> algorithm is &#x201C;global&#x201D;, in the sense that it may exploit the global topology of the graph, but it is also intrinsically local, since at each step each vertex can be processed considering only its direct neighbours. From this standpoint its local implementation is straightforward, since it is sufficient to iteratively process each vertex, its edges and its directly connected vertices to obtain a &#x201C;vertex-centric&#x201D; implementation of the algorithm. Other algorithms that can process the adjacency matrix of a graph row by row (e.g., label propagation algorithms [<xref ref-type="bibr" rid="B9">9</xref>]) can be easily implemented according to a vertex-centric programming model and can benefit from disk-based approaches. More in general the proposed approach can be extended to any other network-based method for which a local implementation can be provided.</p>
        <sec>
          <title>Basic notation</title>
          <p>Having a graph <italic>G</italic>=&lt;<italic>V</italic>,<italic>E</italic>&gt;, representing a functional network, where the vertices <italic>V</italic> correspond to proteins, and edges <italic>E</italic> to functional relationships between proteins, we indicate proteins with integers, i.e. <italic>V</italic>={1,2,&#x2026;,<italic>n</italic>}, where <italic>n</italic>=|<italic>V</italic>| is the number of vertices/proteins, and edges (<italic>i</italic>,<italic>j</italic>)&#x2208;<italic>E</italic> represent functional relationships between vertices <italic>i</italic>,<italic>j</italic>&#x2208;<italic>V</italic>. The weights <inline-formula><mml:math id="M1" name="2047-217X-3-5-i1" overflow="scroll"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ij</mml:mtext></mml:mrow></mml:msub><mml:mo>&#x2208;</mml:mo><mml:mi>&#x211D;</mml:mi></mml:math></inline-formula> associated with edges (<italic>i</italic>,<italic>j</italic>) represent the &#x201C;strength&#x201D; of their functional relationships and are elements of the symmetric weight matrix <bold>
<italic>W</italic>
</bold>. <italic>C</italic>&#x2282;<italic>V</italic> indicates the proteins belonging to a functional class <italic>c</italic> (e.g., a specific Gene Ontology (GO) term [<xref ref-type="bibr" rid="B27">27</xref>]).</p>
        </sec>
        <sec>
          <title>Local implementation of random walks</title>
          <p><italic>Random walk</italic> (<italic>RW</italic>) algorithms [<xref ref-type="bibr" rid="B8">8</xref>] explore and exploit the topology of the functional network, starting and walking around from a subset <italic>C</italic>&#x2282;<italic>V</italic> of nodes belonging to a specific class <italic>c</italic> by using a transition probability matrix <bold>
<italic>Q</italic>
</bold>=<bold>
<italic>D</italic>
</bold><sup>&#x2212;1</sup><bold>
<italic>W</italic>
</bold>, where <bold>
<italic>D</italic>
</bold> is a diagonal matrix with diagonal elements <inline-formula><mml:math id="M2" name="2047-217X-3-5-i2" overflow="scroll"><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ii</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>&#x2211;</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ij</mml:mtext></mml:mrow></mml:msub></mml:math></inline-formula>. The elements <italic>q</italic><sub>
<italic>i</italic>
<italic>j</italic>
</sub> of <bold>
<italic>Q</italic>
</bold> represent the probability of a random step from <italic>i</italic> to <italic>j</italic>.</p>
          <p>The probability to start the walk can be set to <italic>p</italic><sup>
<italic>o</italic>
</sup>=1/|<italic>C</italic>| for the nodes <italic>i</italic>&#x2208;<italic>C</italic> and to <italic>p</italic><sup>
<italic>o</italic>
</sup>=0 for the proteins <italic>i</italic>&#x2208;<italic>V</italic>&#x2216;<italic>C</italic>. If <bold>
<italic>p</italic>
</bold><sup>
<italic>t</italic>
</sup> represents the probability vector of finding a &#x201C;random walker&#x201D; at step <italic>t</italic> in the nodes <italic>i</italic>&#x2208;<italic>V</italic> (that is, <inline-formula><mml:math id="M3" name="2047-217X-3-5-i3" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> represents the probability for a random walk of reaching node <italic>i</italic> at step <italic>t</italic>), then the probability at step <italic>t</italic>+1 is:</p>
          <p>
            <disp-formula id="bmcM1">
              <label>(1)</label>
              <mml:math id="M4" name="2047-217X-3-5-i4" overflow="scroll">
                <mml:msup>
                  <mml:mrow>
                    <mml:mi mathvariant="bold-italic">p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>t</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>=</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi mathvariant="bold-italic">Q</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>T</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi mathvariant="bold-italic">p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>t</mml:mi>
                  </mml:mrow>
                </mml:msup>
              </mml:math>
            </disp-formula>
          </p>
          <p>and the update (1) is iterated until convergence or until a finite number of steps is reached.</p>
          <p>From a &#x201C;vertex-centric&#x201D; standpoint the update rule (1) of the <italic>RW</italic> algorithm becomes:</p>
          <p>
            <disp-formula id="bmcM2">
              <label>(2)</label>
              <mml:math id="M5" name="2047-217X-3-5-i5" overflow="scroll">
                <mml:msubsup>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>t</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msubsup>
                <mml:mo>=</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>Q</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>&#xB7;</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi mathvariant="bold-italic">p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>t</mml:mi>
                  </mml:mrow>
                </mml:msup>
              </mml:math>
            </disp-formula>
          </p>
          <p>where <italic>p</italic><sub>
<italic>i</italic>
</sub> is the probability of the <italic>i</italic><sup>
<italic>t</italic>
<italic>h</italic>
</sup> node, and <italic>Q</italic><sub>
<italic>i</italic>
</sub> represents the <italic>i</italic><sup>
<italic>t</italic>
<italic>h</italic>
</sup> column of the probability transition matrix <bold>
<italic>Q</italic>
</bold>. By recalling that <bold>
<italic>W</italic>
</bold> represents the original weighted adjacency matrix of the graph and <italic>W</italic><sub>
<italic>i</italic>
</sub> its <italic>i</italic><sup>
<italic>t</italic>
<italic>h</italic>
</sup> column, from (2) we obtain:</p>
          <p>
            <disp-formula id="bmcM3">
              <label>(3)</label>
              <mml:math id="M6" name="2047-217X-3-5-i6" overflow="scroll">
                <mml:msubsup>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>t</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msubsup>
                <mml:mo>=</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi>D</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mo>&#x2212;</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>&#xB7;</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>W</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>&#xB7;</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi mathvariant="bold-italic">p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>t</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>=</mml:mo>
                <mml:munderover>
                  <mml:mrow>
                    <mml:mo>&#x2211;</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                </mml:munderover>
                <mml:msubsup>
                  <mml:mrow>
                    <mml:mi>d</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mtext mathvariant="italic">jj</mml:mtext>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mo>&#x2212;</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msubsup>
                <mml:mspace width="2.77626pt"/>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>w</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mtext mathvariant="italic">ji</mml:mtext>
                  </mml:mrow>
                </mml:msub>
                <mml:mspace width="2.77626pt"/>
                <mml:msubsup>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>t</mml:mi>
                  </mml:mrow>
                </mml:msubsup>
              </mml:math>
            </disp-formula>
          </p>
          <p>Equation (3) is the update rule of the random walk resolved at the <italic>i</italic><sup>
<italic>t</italic>
<italic>h</italic>
</sup> node of the graph, and can be viewed as a &#x201C;local&#x201D; version of (1): by updating all the nodes <italic>i</italic> of the graph, 1&#x2264;<italic>i</italic>&#x2264;<italic>n</italic>, we update the probability vector <bold>
<italic>p</italic>
</bold><sup>
<italic>t</italic>+1</sup> exactly in the same way of (1). To compute (3) we need the following information: </p>
          <p>1. <inline-formula><mml:math id="M7" name="2047-217X-3-5-i7" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">jj</mml:mtext></mml:mrow><mml:mrow><mml:mo>&#x2212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mspace width="0.3em"/><mml:mo>=</mml:mo><mml:mspace width="0.3em"/><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:munder><mml:mrow><mml:mo>&#x2211;</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ji</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mspace width="0.3em"/></mml:math></inline-formula> (i.e., the inverse of the sum of weights of the edges coming from <italic>j</italic>)</p>
          <p>2. <italic>w</italic><sub>
<italic>j</italic>
<italic>i</italic>
</sub>,1&#x2264;<italic>j</italic>&#x2264;<italic>n</italic> (i.e., the weights of the inedges of <italic>i</italic>)</p>
          <p>3. <inline-formula><mml:math id="M8" name="2047-217X-3-5-i8" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x2264;</mml:mo><mml:mi>j</mml:mi><mml:mo>&#x2264;</mml:mo><mml:mi>n</mml:mi></mml:math></inline-formula> (i.e., the probabilities of node <italic>j</italic> at the previous step).</p>
          <p>We can observe the following facts: </p>
          <p>a) If the graph is undirected (and this is the case for the AFP problem), the weights of incoming and outcoming edges are the same, that is &#x2200;<italic>i</italic>,&#x2200;<italic>j</italic><italic>w</italic><sub>
<italic>i</italic>
<italic>j</italic>
</sub>=<italic>w</italic><sub>
<italic>j</italic>
<italic>i</italic>
</sub>. This implies that only the list of edge weights outcoming from <italic>i</italic>: <italic>L</italic>(<italic>i</italic>)={<italic>w</italic><sub>
<italic>i</italic>
<italic>j</italic>
</sub>|<italic>w</italic><sub>
<italic>i</italic>
<italic>j</italic>
</sub>&gt;0} should be stored. This in turn implies that in sparse graphs the spatial (and temporal) complexity at each node is sublinear, and (3) can be expressed as:</p>
          <p>
            <disp-formula id="bmcM4">
              <label>(4)</label>
              <mml:math id="M9" name="2047-217X-3-5-i9" overflow="scroll">
                <mml:msubsup>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>t</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msubsup>
                <mml:mo>=</mml:mo>
                <mml:munder>
                  <mml:mrow>
                    <mml:mo>&#x2211;</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                    <mml:mo>&#x2208;</mml:mo>
                    <mml:mi>N</mml:mi>
                    <mml:mo>(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>)</mml:mo>
                  </mml:mrow>
                </mml:munder>
                <mml:msubsup>
                  <mml:mrow>
                    <mml:mi>d</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mtext mathvariant="italic">jj</mml:mtext>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mo>&#x2212;</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msubsup>
                <mml:mspace width="2.77626pt"/>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>w</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mtext mathvariant="italic">ji</mml:mtext>
                  </mml:mrow>
                </mml:msub>
                <mml:mspace width="2.77626pt"/>
                <mml:msubsup>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>t</mml:mi>
                  </mml:mrow>
                </mml:msubsup>
              </mml:math>
            </disp-formula>
          </p>
          <p>where <italic>N</italic>(<italic>i</italic>)={<italic>j</italic>|<italic>j</italic>&#x2208;<italic>V</italic>&#x2227;(<italic>i</italic>,<italic>j</italic>)&#x2208;<italic>E</italic>} are the neighborhood vertices of <italic>i</italic>.</p>
          <p>b) We need to store <inline-formula><mml:math id="M10" name="2047-217X-3-5-i10" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo></mml:math></inline-formula> and <inline-formula><mml:math id="M11" name="2047-217X-3-5-i11" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:math></inline-formula>, 1&#x2264;<italic>j</italic>&#x2264;<italic>n</italic>, that is the probabilities at the current and previous step. Once a step is completed, the current probabilities (<inline-formula><mml:math id="M12" name="2047-217X-3-5-i12" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:math></inline-formula>) can be used as starting probabilities for the next iteration.</p>
          <p>c) We can store <inline-formula><mml:math id="M13" name="2047-217X-3-5-i13" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">jj</mml:mtext></mml:mrow><mml:mrow><mml:mo>&#x2212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x2264;</mml:mo><mml:mi>j</mml:mi><mml:mo>&#x2264;</mml:mo><mml:mi>n</mml:mi></mml:math></inline-formula>, as a value associated to each node <italic>j</italic>. It could be computed at each node <italic>j</italic> as a pre-processing step: <inline-formula><mml:math id="M14" name="2047-217X-3-5-i14" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">jj</mml:mtext></mml:mrow><mml:mrow><mml:mo>&#x2212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:munder><mml:mrow><mml:mo>&#x2211;</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ji</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:math></inline-formula>.</p>
          <p>d) The algorithm iterates for a predefined number of steps or until convergence.</p>
          <p>e) It is easy to see from (3) that the complexity of each iteration of the algorithm is <inline-formula><mml:math id="M15" name="2047-217X-3-5-i15" overflow="scroll"><mml:mi mathvariant="script">O</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math></inline-formula>, but with sparse graphs, i.e. when &#x2200;<italic>i</italic>,|{(<italic>j</italic>,<italic>i</italic>)|<italic>w</italic><sub>
<italic>j</italic>
<italic>i</italic>
</sub>&gt;0}|&lt;&lt;<italic>n</italic>, the complexity is <inline-formula><mml:math id="M16" name="2047-217X-3-5-i16" overflow="scroll"><mml:mi mathvariant="script">O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula>.</p>
        </sec>
      </sec>
      <sec>
        <title>Secondary memory-based computation</title>
        <p>To be actually applicable to real-world big networks, the local implementations of the algorithm described in Section &#x201C;Local implementation of network-based algorithms&#x201D; require specific technologies for an efficient access to the secondary memory: indeed we need to efficiently load small parts of a graph, update them in primary memory and finally store them back to disk.</p>
        <p>To this end we experimented with two different secondary memory-based technologies. The first one is based on graph DB technologies [<xref ref-type="bibr" rid="B28">28</xref>], and the second one on efficient technologies for disk-based processing of graphs.</p>
        <sec>
          <title>Neo4j: a DB technology for graph querying and processing</title>
          <p><italic>Neo4j</italic>[<xref ref-type="bibr" rid="B17">17</xref>] is a data management system written in Java based on the graph data model. Nodes, relationships and their properties are first class citizen in the model and their storage on disk is optimized by the adoption of specific data structures for graph networks. The <italic>Neo4j</italic> Kernel is a fast graph engine with the main characteristics expected by a DBMS, like recovery, management of transactions and indexing structures. <italic>Neo4j</italic> can be used both as an embedded database within a Java application and as a standalone server with an extensive REST interface for easy integration with Web applications. A declarative query language, named <italic>cypher</italic>, for the specification of SQL-style queries is provided.</p>
          <p>Internally, <italic>Neo4j</italic> stores graph data spread across a number of files. Each store file contains the data for a specific part of the graph (e.g. nodes, relationships, properties) and their overall organization, which entails the separation of graph structure from property data, allows the efficient traversal of the graph and the generation of query answers. Both nodes, relationships and properties have a fixed size representation (e.g. nodes have a fixed dimension of 9 bytes), and relationships are implemented using doubly linked lists on disk in order to render efficient their traversal. The fixed-size representation of nodes, relationships and properties has the advantage that identifiers should not be stored (corresponds to the file offset) and that their retrieval by means of their identifiers can be done in constant time.</p>
          <p>Since this information is stored in secondary memory, its access is made efficient through the use of caching techniques. At file system level, each store file is divided in equally sized regions and these regions are cached. The cache holds a fixed number of regions for each file, and regions are replaced relying on a least frequently used (LFU)-like policy. On top of this mechanism, a more specific node/relationship cache has been implemented that is optimized for traversal (for example, relationships of a node are organized relying on their type and their direction).</p>
          <p>In <italic>Neo4j</italic> the functional network <italic>G</italic> used for AFP has been implemented as follows. Each node representing a protein <italic>i</italic> is associated with the properties name, d (i.e. <inline-formula><mml:math id="M17" name="2047-217X-3-5-i17" overflow="scroll"><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:munder><mml:mrow><mml:mo>&#x2211;</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ij</mml:mtext></mml:mrow></mml:msub></mml:math></inline-formula>), p1 and p2 (i.e. the probability of the protein at the previous and current step). Moreover, between two proteins <italic>i</italic> and <italic>j</italic> a relationship of type SIM is specified with a property <italic>w</italic><sub>
<italic>i</italic>
<italic>j</italic>
</sub> containing the strength of their functional relationship. The graph has been enhanced with nodes representing the functional classes (with name and count properties, i.e. the name of the class and the number of proteins belonging to the class) and relationships of type CLASS, that represent the classes to which a protein belongs to. Figure <xref ref-type="fig" rid="F1">1</xref> reports a simple example of the graph with 10 bacteria proteins and two GO terms with their relationships. For the sake of simplicity, the values of p1 and p2 are not reported.</p>
          <fig id="F1" position="float">
            <label>Figure 1</label>
            <caption>
              <p><bold>A sample </bold><bold><italic>Neo4j </italic></bold><bold>net.</bold> A graphical representation of a sample <italic>Neo4j</italic> net.</p>
            </caption>
            <graphic xlink:href="2047-217X-3-5-1"/>
          </fig>
          <p>Even if the <italic>RW</italic> algorithm described in Section &#x201C;Local implementation of network-based algorithms&#x201D; has been implemented in Java with the embedded version of Neo4j, it can be easily expressed through the cypher language. This declarative query language allows the expression of the core definition of the &#x201C;vanilla&#x201D; <italic>RW</italic> with a single simple statement (Figure <xref ref-type="fig" rid="F2">2</xref>). More precisely, starting from a generic protein <italic>i</italic> and a function class named <italic>c</italic>, the cypher implementation identifies the proteins <italic>j</italic> for which a relationship of type SIM exists with <italic>i</italic> and such that <italic>j</italic> is of class <italic>c</italic>. Then, the probability <italic>i</italic>.p2 (at time <italic>t</italic>+1) is obtained by using the value <italic>j</italic>.<italic>d</italic> and <italic>j</italic>.p1 (the probability computed at time <italic>t</italic>). Finally the statement returns the name of protein <italic>i</italic>, the name of the class <italic>c</italic>, and the computed probability <italic>i</italic>.p2 (Figure <xref ref-type="fig" rid="F2">2</xref>).</p>
          <fig id="F2" position="float">
            <label>Figure 2</label>
            <caption>
              <p><bold><italic>Neo4j</italic></bold><bold> Implementation of 1-step </bold><bold><italic>RW</italic></bold><bold> algorithm in cypher.</bold> The notation (i)-[e:rtype]-&gt;(j) is used to represent a relationship <italic>e</italic> of type <italic>rtype</italic> between nodes <italic>i</italic> and <italic>j</italic>. The dot-notation is used to access a single property of a node/edge.</p>
            </caption>
            <graphic xlink:href="2047-217X-3-5-2"/>
          </fig>
        </sec>
        <sec>
          <title>GraphChi: a disk-based system for graph processing</title>
          <p><italic>GraphChi</italic> is a disk-based system for the analysis of big graphs on single off-the-shelf computers [<xref ref-type="bibr" rid="B16">16</xref>]. Differently from <italic>Neo4j</italic>, <italic>GraphChi</italic> has not been conceived for querying large graph-structured databases, but for efficiently processing graphs stored in secondary memory. To this end it implements specialized data structures to efficiently break large graphs into small parts that can be quickly loaded into primary memory, and provides efficient disk I/O operations to reduce the number of non sequential accesses to disk. Moreover, it offers an asynchronous model of computation that directly supports the vertex-centric programming model.</p>
          <p><italic>GraphChi</italic> requires enough primary memory to contain the edges and their associated values of only a relatively small subset of vertices at a time, while the rest of the graph is efficiently stored on disk. More precisely, the vertices of the graph are split in <italic>K</italic> intervals, and each interval is associated to a <italic>shard</italic> which stores all the inedges for the vertices in the interval itself (Figure <xref ref-type="fig" rid="F3">3</xref>a). Note that the inedges are sorted by their source vertex. The dimensions of the intervals are chosen in such a way that the corresponding shards can be entirely loaded into primary memory: hence all the inedges are available for the vertices in the interval. Moreover, the outedges can be efficiently loaded requiring at most <italic>K</italic> non sequential disk-reads, through the mechanism of the <italic>Parallel Sliding Windows (PSW)</italic>: by exploiting the ordering of the edges with respect to the source vertices, when PSW moves from an interval to the next, it &#x201C;slides&#x201D; a window over each of the shards (Figure <xref ref-type="fig" rid="F3">3</xref>b).</p>
          <fig id="F3" position="float">
            <label>Figure 3</label>
            <caption>
              <p><bold>Efficient disk access with </bold><bold><italic>GraphChi. </italic></bold><bold>(a)</bold> Shards: <italic>I</italic><italic>n</italic><italic>t</italic>1,&#x2026;<italic>I</italic><italic>n</italic><italic>t</italic><italic>K</italic> refer to the <italic>K</italic> intervals in which the vertices are split, while <italic>S</italic>1,&#x2026;<italic>S</italic><italic>K</italic> to the corresponding shards <bold>(b)</bold> Parallel Sliding Windows.</p>
            </caption>
            <graphic xlink:href="2047-217X-3-5-3"/>
          </fig>
          <p>Schematically, the execution flow of <italic>GraphChi</italic> can be summarized in an iterative cycle, repeated across each interval of vertices: </p>
          <p>1. <italic>Read</italic>: select an interval and load in primary memory its inedges stored in the associated shard (the &#x201C;memory shard&#x201D;). Through at most <italic>K</italic> non sequential reads load its outedges.</p>
          <p>2. <italic>Execute</italic>: perform a parallel update of vertices and edges of the memory shard through multi-thread asynchronous computation in primary memory.</p>
          <p>3. <italic>Write</italic>: The updated vertices and edges are written back to disk.</p>
          <p>Note that the mechanism of <italic>Parallel Sliding Windows</italic> requires at most <italic>K</italic><sup>2</sup> non sequential reads/writes on disk for a full visit of the entire graph (<italic>K</italic> reads/writes for each interval), thus resulting in a very efficient management of primary and secondary memory [<xref ref-type="bibr" rid="B16">16</xref>].</p>
          <p>The <italic>GraphChi</italic> implementation of the <italic>RW</italic> algorithm requires a data structure for representing a vertex containing the same properties specified for the <italic>Neo4J</italic> implementation (namely, d, p1 and p2 &#x2013; Section &#x201C;Neo4j: a DB technology for graph querying and processing&#x201D;). Moreover, a weight is associated with each edge e (referred to as <italic>e</italic>.<italic>w</italic><sub>
<italic>i</italic>
<italic>j</italic>
</sub>). Figure <xref ref-type="fig" rid="F4">4</xref> reports the pseudo-code of the 1-step RW vertex-centric implementation, including the <italic>start</italic> and the <italic>update</italic> functions, that specify the actions to perform on a vertex i during the first and the succeeding update iterations. In the start function each vertex is initialized with the value of d and the initial probability p1. In the update function the probability of the 1-step RW algorithm is determined by simply applying eq. 4. By means of the <italic>GraphChi</italic> execution engine, these functions are automatically applied to all the vertices of the graph, according to a multi-thread and asynchronous mode of computation. This implementation can be easily extended to an arbitrary number of steps by modifying the <italic>update</italic> function in order to read previous probabilities from p1 during the odd iterations and from p2 during the even iterations (and writing the current probability in the other variable).</p>
          <fig id="F4" position="float">
            <label>Figure 4</label>
            <caption>
              <p>
                <bold>Pseudocode of the </bold>
                <bold>
<italic>GraphChi </italic>
</bold>
                <bold>vertex-centric implementation of the 1-step </bold>
                <bold>
<italic>RW </italic>
</bold>
                <bold>algorithm.</bold>
              </p>
            </caption>
            <graphic xlink:href="2047-217X-3-5-4"/>
          </fig>
          <p>The C++ implementation of this algorithm in <italic>GraphChi</italic> entails to keep in main memory a global vector containing a copy of the data structures for each vertex <italic>v</italic>&#x2208;<italic>V</italic>. Indeed, during the execution of the <italic>update</italic> function, it is only possible to access the identifier of the neighbour vertex j contained in the data structure representing the edge <italic>e</italic>, but not its associated probability <italic>j</italic>.<italic>p</italic>1 and <italic>j</italic>.<italic>d</italic> values, necessary for the computation of the probability <italic>i</italic>.<italic>p</italic>2 (Figure <xref ref-type="fig" rid="F4">4</xref>). Therefore, the global vector in main memory is used just to access this information. We remark that this solution makes our implementation even faster and feasible in our AFP context, since the number of vertices is by far smaller than the number of edges, and thus there is no risk of running out of memory also with off-the-shelf computers, even for very large biological networks involving hundreds of thousands or even millions of proteins.</p>
        </sec>
      </sec>
    </sec>
    <sec>
      <title>Analyses</title>
      <p>We applied our methods based on the local implementation of network-based algorithms and secondary memory-based computation to the multi-species protein function prediction in bacteria and eukarya. In the remainder of the section we summarize the experimental set-up and the characteristics of the data, and then we compare the empirical computational time required by secondary and primary memory-based implementations of network based algorithms for AFP.</p>
      <sec>
        <title>Data description and experimental set-up</title>
        <p>We applied our methods to two multi-species networks of proteins: the first one (<italic>Bacteria-net</italic>, Section &#x201C;Bacteria-net&#x201D;) accounts 301 species of bacteria, and the second one (<italic>Eukarya-net</italic>, Section &#x201C;Eukarya-net&#x201D;) includes the proteomes of 13 Eukaryotic species.</p>
        <sec>
          <title>Bacteria-net</title>
          <p>We constructed a multi-species bacteria network (<italic>Bacteria-net</italic>), using the proteins proposed as part of a large scale experiment for a recent international challenge aimed at the evaluation of gene function prediction methods (CAFA2: [<xref ref-type="bibr" rid="B29">29</xref>]).</p>
          <p>The CAFA2 bacteria proteins belong to 10 species (Table <xref ref-type="table" rid="T1">1</xref>) and amount to 15,451. We added to this set other 2,187 bacteria proteins having at least one experimental GO annotation in the Uniprot knowledgebase/Swissprot (release: May 2013), but coming from organisms not considered in the CAFA2 challenge<sup>a</sup>, for a total of 17,638 bacteria proteins belonging to 301 different species.</p>
          <table-wrap position="float" id="T1">
            <label>Table 1</label>
            <caption>
              <p>CAFA2 bacteria species and their proteins available in Swissprot (May 2013)</p>
            </caption>
            <table frame="hsides" rules="groups" border="1">
              <colgroup>
                <col align="left"/>
                <col align="left"/>
                <col align="left"/>
              </colgroup>
              <thead valign="top">
                <tr>
                  <th align="left">
                    <bold>ID.</bold>
                  </th>
                  <th align="left">
                    <bold>Species</bold>
                  </th>
                  <th align="left">
                    <bold>n. proteins</bold>
                  </th>
                </tr>
              </thead>
              <tbody valign="top">
                <tr>
                  <td align="left" valign="bottom">83333<hr/></td>
                  <td align="left" valign="bottom">Escherichia <italic>coli</italic><hr/></td>
                  <td align="left" valign="bottom">4431<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">224308<hr/></td>
                  <td align="left" valign="bottom">Bacillus <italic>subtilis</italic><hr/></td>
                  <td align="left" valign="bottom">4188<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">99287<hr/></td>
                  <td align="left" valign="bottom">Salmonella <italic>typhimurium</italic><hr/></td>
                  <td align="left" valign="bottom">1771<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">208964<hr/></td>
                  <td align="left" valign="bottom">Pseudomonas <italic>aeruginosa</italic><hr/></td>
                  <td align="left" valign="bottom">1245<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">321314<hr/></td>
                  <td align="left" valign="bottom">Salmonella <italic>enterica</italic><italic>choleraesuis</italic><hr/></td>
                  <td align="left" valign="bottom">882<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">160488<hr/></td>
                  <td align="left" valign="bottom">Pseudomonas <italic>putida</italic><hr/></td>
                  <td align="left" valign="bottom">693<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">223283<hr/></td>
                  <td align="left" valign="bottom">Pseudomonas <italic>syringae</italic><hr/></td>
                  <td align="left" valign="bottom">675<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">85962<hr/></td>
                  <td align="left" valign="bottom">Helicobacter <italic>pylori</italic><hr/></td>
                  <td align="left" valign="bottom">581<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">170187<hr/></td>
                  <td align="left" valign="bottom">Streptococcus <italic>pneumoniae</italic><hr/></td>
                  <td align="left" valign="bottom">502<hr/></td>
                </tr>
                <tr>
                  <td align="left">243273</td>
                  <td align="left">Mycoplasma <italic>genitalium</italic></td>
                  <td align="left">483</td>
                </tr>
              </tbody>
            </table>
            <table-wrap-foot>
              <p>The first column reports the SwissProt organism identifier, the last one the number of proteins.</p>
            </table-wrap-foot>
          </table-wrap>
          <p>Figure <xref ref-type="fig" rid="F5">5</xref> sketches the main steps for the construction of the net of bacteria proteins. At first, we have collected data from the different databases reported in Table <xref ref-type="table" rid="T2">2</xref> to obtain different profiles for each protein. More precisely, each protein has been associated to a binary feature vector, representing a protein profile, whose elements are 1 when the protein is annotated for a specific feature (e.g. includes a specific domain, or a specific motif), or 0 otherwise (second phase in Figure <xref ref-type="fig" rid="F5">5</xref>). The protein profiles have then been used to construct a set of similarity networks (one for each data type) with edge scores based on the computation of the classical Jaccard similarity coefficient between each possible pair of protein profiles, thus obtaining 8 protein networks. Then we constructed two additional networks by computing the hierarchical Jaccard similarities between the Molecular Function (MF) and Cellular Component (CC) profiles associated to each protein and populated only with the experimentally supported GO annotations previously extracted from Swissprot (May 2013). The hierarchical Jaccard index is computed in the same way of the classical Jaccard, but the components of the vector (the GO terms) are weighted according to their distance from the leaves: GO terms corresponding to the leaves have weight <italic>w</italic>=1, those at distance <italic>d</italic>=1 weight <italic>w</italic>=1/2, and more in general nodes at distance <italic>d</italic> have weight <inline-formula><mml:math id="M18" name="2047-217X-3-5-i18" overflow="scroll"><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:math></inline-formula>. In this way we put more emphasis on the most specific annotations, and two proteins annotated with the same more specific terms receive a similarity score larger than that obtained by two proteins annotated with less specific GO terms.</p>
          <fig id="F5" position="float">
            <label>Figure 5</label>
            <caption>
              <p><bold>Construction of bacteria net.</bold> Data flows from different sources of information, construction of the data-type specific networks and networks integration.</p>
            </caption>
            <graphic xlink:href="2047-217X-3-5-5"/>
          </fig>
          <table-wrap position="float" id="T2">
            <label>Table 2</label>
            <caption>
              <p>Public databases exploited for the construction of protein profiles</p>
            </caption>
            <table frame="hsides" rules="groups" border="1">
              <colgroup>
                <col align="left"/>
                <col align="left"/>
              </colgroup>
              <thead valign="top">
                <tr>
                  <th align="left">
                    <bold>Database</bold>
                  </th>
                  <th align="left">
                    <bold>Description</bold>
                  </th>
                </tr>
              </thead>
              <tbody valign="top">
                <tr>
                  <td align="left" valign="bottom">Pfam [<xref ref-type="bibr" rid="B30">30</xref>]<hr/></td>
                  <td align="left" valign="bottom">Protein domain<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">Protein superfamilies [<xref ref-type="bibr" rid="B31">31</xref>]<hr/></td>
                  <td align="left" valign="bottom">Structural and functional annotations<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">PRINTS [<xref ref-type="bibr" rid="B32">32</xref>]<hr/></td>
                  <td align="left" valign="bottom">Motif fingerprints<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">PROSITE [<xref ref-type="bibr" rid="B33">33</xref>]<hr/></td>
                  <td align="left" valign="bottom">Protein domains and families<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">InterPro [<xref ref-type="bibr" rid="B34">34</xref>]<hr/></td>
                  <td align="left" valign="bottom">Integrated resource of protein families, domains and functional sites<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">EggNOG [<xref ref-type="bibr" rid="B35">35</xref>]<hr/></td>
                  <td align="left" valign="bottom">Evolutionary genealogy of genes: Non-supervised Orthologous Groups<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">SMART [<xref ref-type="bibr" rid="B36">36</xref>]<hr/></td>
                  <td align="left" valign="bottom">Simple Modular Architecture Research Tool (database annotations)<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">Swissprot<hr/></td>
                  <td align="left" valign="bottom">Manually curated keywords describing the function of the proteins<hr/></td>
                </tr>
                <tr>
                  <td align="left">&#xA0;</td>
                  <td align="left">at different degrees of abstraction</td>
                </tr>
              </tbody>
            </table>
          </table-wrap>
          <p>The 10 protein networks constructed according to the previously described steps have been integrated in an unique &#x201C;consensus&#x201D; network using the <italic>Unweighted Average</italic> (UA) network integration scheme [<xref ref-type="bibr" rid="B37">37</xref>]: the weight of each edge is computed by simply averaging across the available <italic>n</italic> networks, and &#x201C;missing data&#x201D;, i.e. pairs of vertices <italic>i</italic>,<italic>j</italic> not present in a given network, result in a weight <italic>w</italic><sub>
<italic>i</italic>
<italic>j</italic>
</sub>=0:</p>
          <p>
            <disp-formula id="bmcM5">
              <label>(5)</label>
              <mml:math id="M19" name="2047-217X-3-5-i19" overflow="scroll">
                <mml:msub>
                  <mml:mrow>
                    <mml:mover accent="true">
                      <mml:mrow>
                        <mml:mi>w</mml:mi>
                      </mml:mrow>
                      <mml:mo>&#xAF;</mml:mo>
                    </mml:mover>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mtext mathvariant="italic">ij</mml:mtext>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                </mml:mfrac>
                <mml:munderover accentunder="false" accent="false">
                  <mml:mrow>
                    <mml:mo>&#x2211;</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>d</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                </mml:munderover>
                <mml:msubsup>
                  <mml:mrow>
                    <mml:mi>w</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mtext mathvariant="italic">ij</mml:mtext>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>d</mml:mi>
                  </mml:mrow>
                </mml:msubsup>
              </mml:math>
            </disp-formula>
          </p>
          <p>where <inline-formula><mml:math id="M20" name="2047-217X-3-5-i20" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mo>&#xAF;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ij</mml:mtext></mml:mrow></mml:msub></mml:math></inline-formula> is the weight of the integrated network and <inline-formula><mml:math id="M21" name="2047-217X-3-5-i21" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ij</mml:mtext></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> represents the weight associated to the edge (<italic>i</italic>,<italic>j</italic>) of the <italic>d</italic><sup>
<italic>t</italic>
<italic>h</italic>
</sup> network (final phase of Figure <xref ref-type="fig" rid="F5">5</xref>).</p>
          <p>As class labels for the proteins included in our integrated network we used the Gene Ontology Biological process (BP) experimental annotations extracted from Swissprot (May 2013). To ensure the availability of a reasonable amount of vertices from which to start the exploration of the direct and indirect neighborhood in the integrated protein network, we discarded all the GO BP classes with less than 20 annotated proteins, and this led to a final set of 381 GO terms with an amount of positives varying from 21 to 2,000 (Table <xref ref-type="table" rid="T3">3</xref>).</p>
          <table-wrap position="float" id="T3">
            <label>Table 3</label>
            <caption>
              <p>Summary of the distribution of the number of positives across the 381 GO BP classes involved in the functional labelling of the 17638 proteins comprised in the bacterial multi species protein network</p>
            </caption>
            <table frame="hsides" rules="groups" border="1">
              <colgroup>
                <col align="center"/>
                <col align="center"/>
                <col align="center"/>
                <col align="center"/>
                <col align="center"/>
                <col align="center"/>
              </colgroup>
              <thead valign="top">
                <tr>
                  <th align="center">
                    <bold>Min.</bold>
                  </th>
                  <th align="center">
                    <bold>1st Qu.</bold>
                  </th>
                  <th align="center">
                    <bold>Median</bold>
                  </th>
                  <th align="center">
                    <bold>Mean</bold>
                  </th>
                  <th align="center">
                    <bold>3rd Qu.</bold>
                  </th>
                  <th align="center">
                    <bold>Max.</bold>
                  </th>
                </tr>
              </thead>
              <tbody valign="top">
                <tr>
                  <td align="center">21.0</td>
                  <td align="center">31.0</td>
                  <td align="center">53.0</td>
                  <td align="center">135.4</td>
                  <td align="center">131.0</td>
                  <td align="center">2000.0</td>
                </tr>
              </tbody>
            </table>
          </table-wrap>
          <p>The performance of the considered methods have been quantified both in terms of area under the receiving operating curve (AUC) and precision at different recall levels in a standard 5 folds stratified cross validation scheme. We compared the execution times required for the completion of each ranking task in primary memory (on a machine with 16 Gb of RAM) and in secondary memory (on two machines with 16 and 4 Gb of RAM). The machine with 16 Gb of RAM has been equipped with an i7 Intel core processor with 8 cores at 2.80 GHz, while the 4 Gb machine with an Intel i7 core processor with 4 cores at 1.90 GHz (both have been equipped with off-the-shelf ATA hard disk drives). Both the machines run an Ubuntu 12.04 Linux operating system.</p>
        </sec>
        <sec>
          <title>Eukarya-net</title>
          <p>In order to test the ability of the proposed local methods to scale to large multi-species networks, we constructed a second network (hereafter referred to as <italic>Eukarya-net</italic>). Instead of considering different types of data, as we did in the construction of <italic>Bacteria-net</italic>, all the proteins interactions composing <italic>Eukarya-net</italic> were downloaded in precomputed form from the STRING protein-protein interactions database. STRING [<xref ref-type="bibr" rid="B38">38</xref>] is a collection of networks composed by real and predicted protein-protein interactions (based on genetic data, physical data and literature data) and aims at providing a global view of all the available interaction data, including lower-quality data and/or computational predictions for as many organisms as feasible [<xref ref-type="bibr" rid="B39">39</xref>]. Since version 7, STRING adopted a two-layered approach when accommodating fully sequenced genomes: important model organisms and those for which experimental data are available from the &#x201C;core genomes&#x201D;, while all the other genomes represent the &#x201C;periphery&#x201D; [<xref ref-type="bibr" rid="B40">40</xref>]. Starting from the STRING interaction data (version 9.05), we selected all the Eukaryotic species in the core region of STRING having 10,000 or more proteins. Our choice is motivated by the expected high quality of the interactions coming from the core region of STRING. The selected Eukaryotic species are listed in Table <xref ref-type="table" rid="T4">4</xref>.</p>
          <table-wrap position="float" id="T4">
            <label>Table 4</label>
            <caption>
              <p>Selected species from the core region of the STRING protein networks database</p>
            </caption>
            <table frame="hsides" rules="groups" border="1">
              <colgroup>
                <col align="center"/>
                <col align="center"/>
                <col align="center"/>
              </colgroup>
              <thead valign="top">
                <tr>
                  <th align="center">
                    <bold>NCBI taxon ID.</bold>
                  </th>
                  <th align="center">
                    <bold>Species</bold>
                  </th>
                  <th align="center">
                    <bold>n. proteins</bold>
                  </th>
                </tr>
              </thead>
              <tbody valign="top">
                <tr>
                  <td align="center" valign="bottom">3218<hr/></td>
                  <td align="center" valign="bottom">Physcomitrella <italic>patens</italic><hr/></td>
                  <td align="center" valign="bottom">10352<hr/></td>
                </tr>
                <tr>
                  <td align="center" valign="bottom">3702<hr/></td>
                  <td align="center" valign="bottom">Arabidopsis <italic>thaliana</italic><hr/></td>
                  <td align="center" valign="bottom">23576<hr/></td>
                </tr>
                <tr>
                  <td align="center" valign="bottom">7227<hr/></td>
                  <td align="center" valign="bottom">Drosophila <italic>melanogaster</italic><hr/></td>
                  <td align="center" valign="bottom">12845<hr/></td>
                </tr>
                <tr>
                  <td align="center" valign="bottom">7739<hr/></td>
                  <td align="center" valign="bottom">Branchiostoma <italic>floridae</italic><hr/></td>
                  <td align="center" valign="bottom">16418<hr/></td>
                </tr>
                <tr>
                  <td align="center" valign="bottom">8364<hr/></td>
                  <td align="center" valign="bottom">Xenopus (Silurana) <italic>tropicalis</italic><hr/></td>
                  <td align="center" valign="bottom">13678<hr/></td>
                </tr>
                <tr>
                  <td align="center" valign="bottom">9031<hr/></td>
                  <td align="center" valign="bottom">Gallus <italic>gallus</italic><hr/></td>
                  <td align="center" valign="bottom">13119<hr/></td>
                </tr>
                <tr>
                  <td align="center" valign="bottom">9258<hr/></td>
                  <td align="center" valign="bottom">Ornithorhynchus <italic>anatinus</italic><hr/></td>
                  <td align="center" valign="bottom">13333<hr/></td>
                </tr>
                <tr>
                  <td align="center" valign="bottom">9606<hr/></td>
                  <td align="center" valign="bottom">Homo <italic>sapiens</italic><hr/></td>
                  <td align="center" valign="bottom">20140<hr/></td>
                </tr>
                <tr>
                  <td align="center" valign="bottom">9615<hr/></td>
                  <td align="center" valign="bottom">Canis lupus <italic>familiaris</italic><hr/></td>
                  <td align="center" valign="bottom">16912<hr/></td>
                </tr>
                <tr>
                  <td align="center" valign="bottom">10090<hr/></td>
                  <td align="center" valign="bottom">Mus <italic>musculus</italic><hr/></td>
                  <td align="center" valign="bottom">20023<hr/></td>
                </tr>
                <tr>
                  <td align="center" valign="bottom">13616<hr/></td>
                  <td align="center" valign="bottom">Monodelphis <italic>domestica</italic><hr/></td>
                  <td align="center" valign="bottom">15409<hr/></td>
                </tr>
                <tr>
                  <td align="center" valign="bottom">39947<hr/></td>
                  <td align="center" valign="bottom">Oryza sativa <italic>Japonica</italic><hr/></td>
                  <td align="center" valign="bottom">13330<hr/></td>
                </tr>
                <tr>
                  <td align="center">69293</td>
                  <td align="center">Gasterosteus <italic>aculeatus</italic></td>
                  <td align="center">13307</td>
                </tr>
              </tbody>
            </table>
            <table-wrap-foot>
              <p>Each species is represented by at least 10000 proteins.</p>
            </table-wrap-foot>
          </table-wrap>
          <p>This network includes proteins coming from 2 invertebrates (a lancelet of the genus Branchiostoma and the fruit fly), 3 plants (<italic>Arabidopsis thaliana</italic>, the rice <italic>Oryza sativa</italic> and the moss <italic>Physcomitrella patens</italic>), and 8 vertebrates including a frog, the chicken and 6 mammals. The total number of proteins in <italic>Eukarya-net</italic> is 202,442. This basic version of <italic>Eukarya-net</italic> is obtained by extracting from STRING all the interactions occurring between proteins of the selected core species. This led to an initial collection of 25,132,538 interactions. A simple connected components analysis revealed that this network is composed by 666 connected components of which only 13 composed by more than 30 vertices (and corresponding to the biggest connected components of the networks associated to each species). This &#x201C;big&#x201D; network is thus a collection of the protein networks of the selected species. In order to find a way to &#x201C;connect&#x201D; the core components, we extracted all the clusters of orthologous genes from the STRING website according to the following steps: </p>
          <p>&#x2022; the cluster of orthologs ID obtained by the STRING team using the eggNOG database (we considered only clusters of type NOG: non-supervised orthologous groups);</p>
          <p>&#x2022; the filtering of each NOG cluster in order to remove the proteins not coming from the selected core species. Note that some NOGs are composed by more than 2,000 proteins, but after our filtering procedure each selected NOG is composed by no more than 10 proteins.</p>
          <p>After these steps, we selected all the NOGs in which the number of proteins equals the number of species (i.e. NOG composed by 10 proteins coming from 10 species, NOG composed by 9 proteins coming from 9 species, and so on). We finally constructed an enriched version of the basic <italic>Eukarya-net</italic> network simply by including in <italic>Eukarya-net</italic> all the possible edges linking the members of the selected set of NOGs. Following this strategy we obtained a network composed by 25,155,631 edges (network density: 0.000613). In order to verify the impact of the additional 23,093 NOGs based edges on the connectivity of <italic>Eukarya-net</italic>, we repeated the connected components analysis and we found that this &#x201C;NOGs augmented&#x201D; version of <italic>Eukarya-net</italic> is composed by 552 connected components of which two (190,755 nodes (94.22%) and 10,233 (5.05%)) account for more than 99% of the 202,442 proteins composing the network.</p>
          <p>As class labels for the proteins included in <italic>Eukarya-net</italic> we used the GO annotations available in STRING (version 9.05). The STRING website provides flat text files containing a mapping from GO annotations to STRING proteins and a STRING internal confidence score for each GO annotation, ranging from 1 (low confidence) to 5 (high confidence). While extracting the GO labels we considered only the annotations with confidence score 5. We then filtered out all the GO terms associated with less than 20 and more than 100 proteins (473 GO terms). We finally randomly selected from this set 50 GO terms irrespective of their GO division (Molecular function, Biological process and Cellular component). We then repeated all the test performed on <italic>Bacteria-net</italic> on the bigger <italic>Eukarya-net</italic> network.</p>
        </sec>
      </sec>
      <sec>
        <title>Results and discussion</title>
        <p>We compared the runtime required by main memory and secondary memory-based implementations (Section &#x201C;Secondary memory-based computation&#x201D;) of the <italic>RW</italic> algorithm described in Section &#x201C;Local implementation of network-based algorithms&#x201D;. Moreover, even if our main aim consists in showing that the combination of local implementation and secondary memory-based computation allows the analysis of big biological networks on small computers, we performed also a comparison of the performance achieved with single-species and multi-species networks of bacteria proteins to experimentally assess the impact of a multi-species approach to the prediction of protein functions.</p>
        <sec>
          <title>Results with <italic>bacteria-net</italic></title>
          <p>Table <xref ref-type="table" rid="T5">5</xref> shows the average per term runtime required to complete a 5-fold cross-validation on the <italic>Bacteria-net</italic> (17,638 nodes/proteins and more than 7 millions of edges). We considered 381 GO BP terms characterized by more than 20 annotations and involving 301 species of bacteria. (see Section &#x201C;Bacteria-net&#x201D; for details). Results on the desktop computer (16 Gb RAM machine) show that the computational time required by the secondary memory based implementations, even if larger, is of the same order of magnitude of the time needed by the main-memory-based implementation. In particular, quite surprisingly, the empirical time complexity of the <italic>GraphChi</italic> implementation is very close to that of the the main-memory version. This fact can be partially explained by the very efficient secondary memory access of <italic>GraphChi</italic>, but above all by the characteristics of the main-memory implementation of the <italic>RW</italic> algorithm. Even if the efficient BLAS-based fortran subroutines for linear algebra are used for the classical stochastic matrix/probability vector product (eq. 1), the sparsity of the <italic>Bacteria-net</italic> network is not adequately exploited.</p>
          <table-wrap position="float" id="T5">
            <label>Table 5</label>
            <caption>
              <p>
                <bold>Empirical time complexity of the main and secondary memory-based implementations of network based algorithms for multi-species function prediction with the </bold>
                <bold>
<italic>Bacteria-net</italic>
</bold>
              </p>
            </caption>
            <table frame="hsides" rules="groups" border="1">
              <colgroup>
                <col align="left"/>
                <col align="right"/>
                <col align="right"/>
                <col align="right"/>
                <col align="center"/>
                <col align="right"/>
                <col align="right"/>
              </colgroup>
              <thead valign="top">
                <tr>
                  <th align="left" valign="bottom">&#xA0;<hr/></th>
                  <th colspan="3" align="center" valign="bottom">
                    <bold>16 Gb RAM machine</bold>
                    <hr/>
                  </th>
                  <th colspan="3" align="center" valign="bottom">
                    <bold>4 Gb RAM machine</bold>
                    <hr/>
                  </th>
                </tr>
                <tr>
                  <th align="left">
                    <bold>
<italic>Algorithm</italic>
</bold>
                  </th>
                  <th align="right">
                    <bold>
<italic>Main mem.</italic>
</bold>
                  </th>
                  <th align="right">
                    <bold>
<italic>Neo4j</italic>
</bold>
                  </th>
                  <th align="right">
                    <bold>
<italic>GraphChi</italic>
</bold>
                  </th>
                  <th align="center">
                    <bold>
<italic>Main mem.</italic>
</bold>
                  </th>
                  <th align="right">
                    <bold>
<italic>Neo4j</italic>
</bold>
                  </th>
                  <th align="right">
                    <bold>
<italic>GraphChi</italic>
</bold>
                  </th>
                </tr>
              </thead>
              <tbody valign="top">
                <tr>
                  <td align="left" valign="bottom">
                    <italic>RW - 1 step</italic>
                    <hr/>
                  </td>
                  <td align="right" valign="bottom">8.11s<hr/></td>
                  <td align="right" valign="bottom">27.92s<hr/></td>
                  <td align="right" valign="bottom">8.84s<hr/></td>
                  <td align="center" valign="bottom">&#x2013;<hr/></td>
                  <td align="right" valign="bottom">208.27s<hr/></td>
                  <td align="right" valign="bottom">12.32s<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">
                    <italic>RW - 2 steps</italic>
                    <hr/>
                  </td>
                  <td align="right" valign="bottom">16.05s<hr/></td>
                  <td align="right" valign="bottom">54.36s<hr/></td>
                  <td align="right" valign="bottom">16.98s<hr/></td>
                  <td align="center" valign="bottom">&#x2013;<hr/></td>
                  <td align="right" valign="bottom">408.57s<hr/></td>
                  <td align="right" valign="bottom">25.06s<hr/></td>
                </tr>
                <tr>
                  <td align="left">
                    <italic>RW - 3 steps</italic>
                  </td>
                  <td align="right">23.95s</td>
                  <td align="right">81.18s</td>
                  <td align="right">25.12s</td>
                  <td align="center">&#x2013;</td>
                  <td align="right">621.92s</td>
                  <td align="right">36.51s</td>
                </tr>
              </tbody>
            </table>
          </table-wrap>
          <p>The results of the main-memory algorithm with the notebook (4 Gb RAM machine) are not reported since on this task the main memory implementation of the algorithm fails, due to disk trashing, by which processor time is mainly used to continuously swap from main memory and the virtual memory on disk. On the contrary, the <italic>GraphChi</italic> implementation results only in a small increment of the computational time, mainly due to the larger time required to construct the shards when less RAM memory is available (Section &#x201C;GraphChi: a disk-based system for graph processing&#x201D;) and to the lower speed of the processor in the notebook machine.</p>
          <p>Note that with the smaller machine the empirical computational time required by <italic>Neo4j</italic> increases of about one order of magnitude, while the <italic>GraphChi</italic> implementation introduces only a small increment of the required execution time (Table <xref ref-type="table" rid="T5">5</xref>). This is particularly relevant when we consider the overall computational time required to predict the 381 GO terms: with the &#x201C;small&#x201D; machine <italic>Neo4j</italic> moves from about 3 hours to about one day with the 1-step <italic>RW</italic>, and from about 7 hours to almost 3 days with the 3-steps <italic>RW</italic>.</p>
          <p>Even if the main aim of this work consists in showing that secondary-memory based technologies allow us to analyse large multi-species networks also with &#x201C;relatively small&#x201D; stand-alone computers, we report also the average AUC, and precision at 20 and 40% recall across the considered 381 GO BP terms. Table <xref ref-type="table" rid="T6">6</xref> shows that <italic>RW</italic> algorithms achieve reasonable results (AUC is always significantly larger than 0.5). In particular 1-step <italic>RW</italic> obtains the best results in terms of both AUC and P20R and P40R: on the average, the direct neighbours of each node seem to be the most informative.</p>
          <table-wrap position="float" id="T6">
            <label>Table 6</label>
            <caption>
              <p>
                <bold>
<italic>Bacteria-net</italic>
</bold>
                <bold>: average AUC, precision at 20% recall (P20R) and precision at 40% recall across 381 GO BP terms estimated through 5-fold cross-validation</bold>
              </p>
            </caption>
            <table frame="hsides" rules="groups" border="1">
              <colgroup>
                <col align="left"/>
                <col align="center"/>
                <col align="center"/>
                <col align="center"/>
              </colgroup>
              <thead valign="top">
                <tr>
                  <th align="left">
                    <bold>Algorithm</bold>
                  </th>
                  <th align="center">
                    <bold>AUC</bold>
                  </th>
                  <th align="center">
                    <bold>P20R</bold>
                  </th>
                  <th align="center">
                    <bold>P40R</bold>
                  </th>
                </tr>
              </thead>
              <tbody valign="top">
                <tr>
                  <td align="left" valign="bottom">
                    <italic>RW - 1 step</italic>
                    <hr/>
                  </td>
                  <td align="center" valign="bottom">0.8744<hr/></td>
                  <td align="center" valign="bottom">0.2264<hr/></td>
                  <td align="center" valign="bottom">0.1673<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">
                    <italic>RW - 2 steps</italic>
                    <hr/>
                  </td>
                  <td align="center" valign="bottom">0.8590<hr/></td>
                  <td align="center" valign="bottom">0.1318<hr/></td>
                  <td align="center" valign="bottom">0.0893<hr/></td>
                </tr>
                <tr>
                  <td align="left">
                    <italic>RW - 3 steps</italic>
                  </td>
                  <td align="center">0.8419</td>
                  <td align="center">0.1064</td>
                  <td align="center">0.0713</td>
                </tr>
              </tbody>
            </table>
          </table-wrap>
        </sec>
        <sec>
          <title>Results with <italic>Eukarya-net</italic></title>
          <p>Table <xref ref-type="table" rid="T7">7</xref> summarizes the average per-term runtime required to complete a 5-fold cross validation with the <italic>Eukarya-net</italic> involving more than 200,000 proteins of 13 multi-cellular eukarya organisms (Section &#x201C;Eukarya-net&#x201D;). The spatial requirements induced by <italic>Eukarya-net</italic> prevents the application of the main memory implementation also with the 16 Gb RAM machine, while secondary memory-based implementations make this task feasible also with this large protein network.</p>
          <table-wrap position="float" id="T7">
            <label>Table 7</label>
            <caption>
              <p>
                <bold>
<italic>Eukarya-net</italic>
</bold>
                <bold>: Average per-term empirical time complexity between</bold>
                <bold>
<italic>Neo4j</italic>
</bold>
                <bold> and</bold>
                <bold>
<italic>GraphChi</italic>
</bold>
                <bold> implementations</bold>
              </p>
            </caption>
            <table frame="hsides" rules="groups" border="1">
              <colgroup>
                <col align="left"/>
                <col align="right"/>
                <col align="right"/>
                <col align="right"/>
                <col align="right"/>
              </colgroup>
              <thead valign="top">
                <tr>
                  <th align="left" valign="bottom">&#xA0;<hr/></th>
                  <th colspan="2" align="center" valign="bottom">
                    <bold>16 Gb RAM machine</bold>
                    <hr/>
                  </th>
                  <th colspan="2" align="center" valign="bottom">
                    <bold>4 Gb RAM machine</bold>
                    <hr/>
                  </th>
                </tr>
                <tr>
                  <th align="left">
                    <bold>
<italic>Algorithm</italic>
</bold>
                  </th>
                  <th align="right">
                    <bold>
<italic>Neo4j</italic>
</bold>
                  </th>
                  <th align="right">
                    <bold>
<italic>GraphChi</italic>
</bold>
                  </th>
                  <th align="right">
                    <bold>
<italic>Neo4j</italic>
</bold>
                  </th>
                  <th align="right">
                    <bold>
<italic>GraphChi</italic>
</bold>
                  </th>
                </tr>
              </thead>
              <tbody valign="top">
                <tr>
                  <td align="left" valign="bottom">
                    <italic>RW - 1 step</italic>
                    <hr/>
                  </td>
                  <td align="right" valign="bottom">189.60s<hr/></td>
                  <td align="right" valign="bottom">20.44s<hr/></td>
                  <td align="right" valign="bottom">2520.00s<hr/></td>
                  <td align="right" valign="bottom">21.46s<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">
                    <italic>RW - 2 steps</italic>
                    <hr/>
                  </td>
                  <td align="right" valign="bottom">367.82s<hr/></td>
                  <td align="right" valign="bottom">31.68s<hr/></td>
                  <td align="right" valign="bottom">4919.35s<hr/></td>
                  <td align="right" valign="bottom">33.19s<hr/></td>
                </tr>
                <tr>
                  <td align="left">
                    <italic>RW - 3 steps</italic>
                  </td>
                  <td align="right">549.84s</td>
                  <td align="right">45.73s</td>
                  <td align="right">7333.10s</td>
                  <td align="right">46.69s</td>
                </tr>
              </tbody>
            </table>
          </table-wrap>
          <p>It is worth noting that in this task involving a bigger net, the <italic>GrapChi</italic> implementation is significantly faster than the <italic>Neo4j</italic> implementation (Table <xref ref-type="table" rid="T7">7</xref>). Moreover, the average computational time is in practice the same when the 4 Gb and the 16 Gb RAM machines run the <italic>GrapChi</italic> implementation of the <italic>RW</italic> algorithm, while we observe a relevant increment in computational time with <italic>Neo4j</italic>, as previously observed also with <italic>Bacteria-net</italic>.</p>
          <p>The performance in terms of the average precision at fixed recall levels obtained in this test are relatively low, especially when compared with the high average AUC obtained with the <italic>RW</italic> at 1, 2 and 3 steps (Table <xref ref-type="table" rid="T8">8</xref>). The observed relatively low precision can be explained by taking into account that it is more negatively affected by class unbalance and, in the <italic>Eukarya-net</italic> network task, the positives are at most 100 while the number of vertices in the network is 202,442 (i.e. the positives are less than 0.05% of the vertices at best). Note that in this case the 2-steps <italic>RW</italic> achieves the best AUC results: it is likely that these results could be due by the eggNOG orthology relationships added between the single-species disconnected components in <italic>Eukarya-net</italic> (Section &#x201C;Eukarya-net&#x201D;). Indeed in this way the annotations for a certain species can be propagated to other philogenetically related species by exploiting the orthology relationships.</p>
          <table-wrap position="float" id="T8">
            <label>Table 8</label>
            <caption>
              <p>
                <bold>
<italic>Eukarya-net</italic>
</bold>
                <bold>: average AUC, precision at 20% recall (P20R) and precision at 40% recall across 50 GO terms estimated through 5-fold cross-validation</bold>
              </p>
            </caption>
            <table frame="hsides" rules="groups" border="1">
              <colgroup>
                <col align="left"/>
                <col align="center"/>
                <col align="center"/>
                <col align="center"/>
              </colgroup>
              <thead valign="top">
                <tr>
                  <th align="left">
                    <bold>Algorithm</bold>
                  </th>
                  <th align="center">
                    <bold>AUC</bold>
                  </th>
                  <th align="center">
                    <bold>P20R</bold>
                  </th>
                  <th align="center">
                    <bold>P40R</bold>
                  </th>
                </tr>
              </thead>
              <tbody valign="top">
                <tr>
                  <td align="left" valign="bottom">
                    <italic>RW - 1 step</italic>
                    <hr/>
                  </td>
                  <td align="center" valign="bottom">0.8601<hr/></td>
                  <td align="center" valign="bottom">0.1449<hr/></td>
                  <td align="center" valign="bottom">0.0943<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">
                    <italic>RW - 2 steps</italic>
                    <hr/>
                  </td>
                  <td align="center" valign="bottom">0.9667<hr/></td>
                  <td align="center" valign="bottom">0.1329<hr/></td>
                  <td align="center" valign="bottom">0.0929<hr/></td>
                </tr>
                <tr>
                  <td align="left">
                    <italic>RW - 3 steps</italic>
                  </td>
                  <td align="center">0.9598</td>
                  <td align="center">0.0927</td>
                  <td align="center">0.0785</td>
                </tr>
              </tbody>
            </table>
          </table-wrap>
        </sec>
        <sec>
          <title>Experimental comparison between multi-species and single-species approaches</title>
          <p>In this section we provide an experimental comparison between multi-species and single-species approaches to <italic>AFP</italic>. We repeated the same <italic>AFP</italic> task performed with <italic>Bacteria-net</italic> but considering this time each species separately. More precisely, we constructed a separate net for each species of Bacteria, using exactly the same data we used for the multi-species net (Section &#x201C;Bacteria-net&#x201D;), and then we predicted the probabilities for each of the 381 GO terms considered in the multi-species task (Section &#x201C;Results with <italic>bacteria-net</italic>&#x201D;). Average per-species results show that the multi-species approach, by exploiting the multi-species network of proteins <italic>Bacteria-net</italic>, achieves better results in terms of both AUC, and precision at a fixed recall rate (Table <xref ref-type="table" rid="T9">9</xref>), and the difference is statistically significant independently of the number of steps and the performance measure considered (Wilcoxon signed rank test, <italic>&#x3B1;</italic>=0.01).</p>
          <table-wrap position="float" id="T9">
            <label>Table 9</label>
            <caption>
              <p>Comparison of the average AUC, precision at 20% recall (P20R) and precision at 40% recall between multi-species and single-species approaches with 301 species of bacteria</p>
            </caption>
            <table frame="hsides" rules="groups" border="1">
              <colgroup>
                <col align="left"/>
                <col align="center"/>
                <col align="center"/>
                <col align="center"/>
              </colgroup>
              <thead valign="top">
                <tr>
                  <th colspan="4" align="center">
                    <bold>Multi-species approach</bold>
                  </th>
                </tr>
              </thead>
              <tbody valign="top">
                <tr>
                  <td align="left" valign="bottom">
                    <bold>Algorithm</bold>
                    <hr/>
                  </td>
                  <td align="center" valign="bottom">
                    <bold>AUC</bold>
                    <hr/>
                  </td>
                  <td align="center" valign="bottom">
                    <bold>P20R</bold>
                    <hr/>
                  </td>
                  <td align="center" valign="bottom">
                    <bold>P40R</bold>
                    <hr/>
                  </td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">
                    <italic>RW - 1 step</italic>
                    <hr/>
                  </td>
                  <td align="center" valign="bottom">0.8744<hr/></td>
                  <td align="center" valign="bottom">0.2264<hr/></td>
                  <td align="center" valign="bottom">0.1673<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">
                    <italic>RW - 2 steps</italic>
                    <hr/>
                  </td>
                  <td align="center" valign="bottom">0.8590<hr/></td>
                  <td align="center" valign="bottom">0.1318<hr/></td>
                  <td align="center" valign="bottom">0.0893<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">
                    <italic>RW - 3 steps</italic>
                    <hr/>
                  </td>
                  <td align="center" valign="bottom">0.8419<hr/></td>
                  <td align="center" valign="bottom">0.1064<hr/></td>
                  <td align="center" valign="bottom">0.0713<hr/></td>
                </tr>
                <tr>
                  <td colspan="4" align="center" valign="bottom">
                    <bold>Single-species approach</bold>
                    <hr/>
                  </td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">
                    <bold>Algorithm</bold>
                    <hr/>
                  </td>
                  <td align="center" valign="bottom">
                    <bold>AUC</bold>
                    <hr/>
                  </td>
                  <td align="center" valign="bottom">
                    <bold>P20R</bold>
                    <hr/>
                  </td>
                  <td align="center" valign="bottom">
                    <bold>P40R</bold>
                    <hr/>
                  </td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">
                    <italic>RW - 1 step</italic>
                    <hr/>
                  </td>
                  <td align="center" valign="bottom">0.8263<hr/></td>
                  <td align="center" valign="bottom">0.1801<hr/></td>
                  <td align="center" valign="bottom">0.1176<hr/></td>
                </tr>
                <tr>
                  <td align="left" valign="bottom">
                    <italic>RW - 2 steps</italic>
                    <hr/>
                  </td>
                  <td align="center" valign="bottom">0.8146<hr/></td>
                  <td align="center" valign="bottom">0.1059<hr/></td>
                  <td align="center" valign="bottom">0.0647<hr/></td>
                </tr>
                <tr>
                  <td align="left">
                    <italic>RW - 3 steps</italic>
                  </td>
                  <td align="center">0.8179</td>
                  <td align="center">0.1009</td>
                  <td align="center">0.0563</td>
                </tr>
              </tbody>
            </table>
          </table-wrap>
          <p>These results can be explained, considering two characteristics of multi-species networks: 1) the number of nodes and the number of available annotated proteins; 2) the overall topology of the network.</p>
          <p>Indeed in single-species nets either the reduced number of available proteins or the reduced number of annotated nodes can negatively affect the generalization capabilities achieved with random walks or any other learning algorithm, while in multi-species networks, by construction, more nodes and more annotated proteins from other species can be available.</p>
          <p>Moreover in single-species networks usually the number of available functional connections (edges) between proteins can be reduced (for instance, since no sufficient data are available) and in many cases we may have highly disconnected networks, making very difficult the application of algorithms based on the propagation of the information between nodes. On the contrary, in the multi-species setting learning algorithms can enjoy a richer network topology by exploring connections not available in single-species nets: the evolutionary relationships between species assure that proteins not connected with other proteins of the same species, can in principle be connected with other homologous proteins in other species, thus enhancing the propagation of the information across the multi-species network.</p>
          <p>Summarizing, our results show the feasibility of the &#x201C;vertex-centric&#x201D; algorithmic approach coupled with secondary memory-based technologies to process large multi-species protein networks with single off-the-shelf computers. Moreover, our preliminary experiments show that in perspective we can also improve performances by constructing large multi-species networks, and by integrating heterogeneous sources of biomolecular and evolutionary information.</p>
        </sec>
      </sec>
    </sec>
    <sec sec-type="conclusions">
      <title>Conclusions</title>
      <p>Our approach based on local implementations of network-based algorithms and on novel secondary memory-based technologies provides a solution to the large main memory requirements induced by large multi-species protein networks, thus making possible the analysis of big networks using off-the-shelf machines. Our results show that both graph DB technologies (i.e. <italic>Neo4j</italic>) and secondary memory based systems for graph processing (i.e. <italic>GraphChi</italic>) can be successfully applied to the analysis of large multi-species networks, even if the latter seems to be less sensitive to the amount of available primary memory, and more efficient for the implementation of network-based algorithms for AFP. The local implementation strategy can be applied to other network-based learning algorithms, ranging e.g. from simple guilt-by-association methods (that are inherently local) [<xref ref-type="bibr" rid="B41">41</xref>,<xref ref-type="bibr" rid="B42">42</xref>] to more complex label propagation methods [<xref ref-type="bibr" rid="B9">9</xref>,<xref ref-type="bibr" rid="B10">10</xref>], kernelized graph algorithms [<xref ref-type="bibr" rid="B25">25</xref>,<xref ref-type="bibr" rid="B43">43</xref>,<xref ref-type="bibr" rid="B44">44</xref>] and the recently proposed parametrized Hopfield networks [<xref ref-type="bibr" rid="B45">45</xref>], but in principle any algorithm, that can be expressed according to a &#x201C;vertex-centric&#x201D; programming model, can be adapted to this framework.</p>
      <p>In perspective, by exploiting orthologous genes and multiple genomic sources, multi-species prediction can be applied to annotate poorly annotated species and discover new functions for uncharacterized genes in model organisms. Indeed our proposed approach allows computational biologists to experiment with large multi-species networks using their own notebooks, but in perspective applications to huge networks including e.g. the proteomes available in SwissProt/TrEmbl could be performed using well-equipped stand-alone machines.</p>
      <p>Our framework could be also adapted and devised to other relevant computational biology scenarios characterized by the construction and processing of large networks, such as in the context of the &#x201C;Network medicine&#x201D; [<xref ref-type="bibr" rid="B46">46</xref>], or in drug discovery and repositioning problems [<xref ref-type="bibr" rid="B47">47</xref>].</p>
    </sec>
    <sec>
      <title>Availability of supporting data</title>
      <p>The files containing the <italic>Bacteria-net</italic> and <italic>Eukarya-net</italic> along with the files containing the labels used in our experiments are available from GigaDB [<xref ref-type="bibr" rid="B48">48</xref>]<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.5524/100090">http://dx.doi.org/10.5524/100090</ext-link>. The content and format of each file is described in readme files available at the aforementioned database.</p>
    </sec>
    <sec>
      <title>Endnote</title>
      <p><sup>a</sup> For experimental annotation we considered all the available associations having GO evidence codes not included in the following list: IEA, ND, IC, NAS, TAS, ISS, ISO, ISA, ISM, IGC, IBA, IBD, IKR, IRD and RCA. A complete list of the GO evidence codes and their meanings is available at <ext-link ext-link-type="uri" xlink:href="http://www.geneontology.org/GO.evidence.shtml">http://www.geneontology.org/GO.evidence.shtml</ext-link>.</p>
    </sec>
    <sec>
      <title>Abbreviations</title>
      <p>AFP: Automated function prediction; BP: Biological process; CC: Cellular component; GO: Gene ontology; MF: Molecular function; RW: Random walk.</p>
    </sec>
    <sec>
      <title>Competing interests</title>
      <p>The authors declare that they have no competing interests.</p>
    </sec>
    <sec>
      <title>Authors&#x2019; contributions</title>
      <p>MM analyzed the technological items behind secondary memory based computation and implemented the <italic>RW</italic> algorithm using Neo4j; MR curated the biological items of multi-species AFP and implemented the same algorithm with GraphChi; GV wrote the draft (with the contribution of the other authors) and implemented the main-memory version of the algorithms. All authors read and approved the final manuscript.</p>
    </sec>
  </body>
  <back>
    <sec>
      <title>Acknowledgements</title>
      <p>The authors would like to thank the reviewers for their useful comments and suggestions, and acknowledge partial support from the <italic>PRIN</italic> project &#x201C;Automi e linguaggi formali: aspetti matematici e applicativi&#x201D;, funded by the italian Ministry of University.</p>
    </sec>
    <ref-list>
      <ref id="B1">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Friedberg</surname>
            <given-names>I</given-names>
          </name>
          <article-title>Automated protein function prediction-the genomic challenge</article-title>
          <source>Brief Bioinform</source>
          <year>2006</year>
          <volume>7</volume>
          <fpage>225</fpage>
          <lpage>242</lpage>
          <pub-id pub-id-type="doi">10.1093/bib/bbl004</pub-id>
          <pub-id pub-id-type="pmid">16772267</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B2">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Gillis</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Pavlidis</surname>
            <given-names>P</given-names>
          </name>
          <article-title>Characterizing the state of the art in the computational assignment of gene function: lessons from the first critical assessment of functional annotation (CAFA)</article-title>
          <source>BMC Bioinformatics</source>
          <year>2013</year>
          <volume>14</volume>
          <issue>Suppl 3</issue>
          <fpage>S15</fpage>
          <pub-id pub-id-type="doi">10.1186/1471-2105-14-S3-S15</pub-id>
          <pub-id pub-id-type="pmid">23630983</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B3">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Radivojac</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Clark</surname>
            <given-names>WT</given-names>
          </name>
          <name>
            <surname>Oron</surname>
            <given-names>TR</given-names>
          </name>
          <name>
            <surname>Schnoes</surname>
            <given-names>AM</given-names>
          </name>
          <name>
            <surname>Wittkop</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Sokolov</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Graim</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Funk</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Verspoor</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Ben-Hur</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Pandey</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Yunes</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Talwalkar</surname>
            <given-names>AS</given-names>
          </name>
          <name>
            <surname>Repo</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Souza</surname>
            <given-names>ML</given-names>
          </name>
          <name>
            <surname>Piovesan</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Casadio</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Cheng</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Fang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Gough</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Koskinen</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>T&#xF6;r&#xF6;nen</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Nokso-Koivisto</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Holm</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Cozzetto</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Buchan</surname>
            <given-names>DWA</given-names>
          </name>
          <name>
            <surname>Bryson</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Jones</surname>
            <given-names>DT</given-names>
          </name>
          <name>
            <surname>Limaye</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
          <article-title>A large-scale evaluation of computational protein function prediction</article-title>
          <source>Nat Methods</source>
          <year>2013</year>
          <volume>10</volume>
          <issue>3</issue>
          <fpage>221</fpage>
          <lpage>227</lpage>
          <pub-id pub-id-type="doi">10.1038/nmeth.2340</pub-id>
          <pub-id pub-id-type="pmid">23353650</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B4">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Wong</surname>
            <given-names>AK</given-names>
          </name>
          <name>
            <surname>Park</surname>
            <given-names>CY</given-names>
          </name>
          <name>
            <surname>Greene</surname>
            <given-names>CS</given-names>
          </name>
          <name>
            <surname>Bongo</surname>
            <given-names>LA</given-names>
          </name>
          <name>
            <surname>Guan</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Troyanskaya</surname>
            <given-names>OG</given-names>
          </name>
          <article-title>IMP: a multi-species functional genomics portal for integration, visualization and prediction of protein functions and networks</article-title>
          <source>Nucleic Acids Res</source>
          <year>2012</year>
          <volume>40</volume>
          <issue>W1</issue>
          <fpage>W484&#x2014;W490</fpage>
          <pub-id pub-id-type="pmid">22684505</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B5">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Kuzniar</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>van Ham</surname>
            <given-names>RC</given-names>
          </name>
          <name>
            <surname>Pongor</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Leunissen</surname>
            <given-names>JA</given-names>
          </name>
          <article-title>The quest for orthologs: finding the corresponding gene across genomes</article-title>
          <source>Trends Genet</source>
          <year>2008</year>
          <volume>24</volume>
          <issue>11</issue>
          <fpage>539</fpage>
          <lpage>551</lpage>
          <pub-id pub-id-type="doi">10.1016/j.tig.2008.08.009</pub-id>
          <pub-id pub-id-type="pmid">18819722</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B6">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Koonin</surname>
            <given-names>EV</given-names>
          </name>
          <article-title>Orthologs, paralogs, and evolutionary genomics 1</article-title>
          <source>Annu Rev Genet</source>
          <year>2005</year>
          <volume>39</volume>
          <fpage>309</fpage>
          <lpage>338</lpage>
          <pub-id pub-id-type="doi">10.1146/annurev.genet.39.073003.114725</pub-id>
          <pub-id pub-id-type="pmid">16285863</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B7">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Hamp</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Kassner</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Seemayer</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Vicedo</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Schaefer</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Achten</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Auer</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Boehm</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Braun</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Hecht</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Heron</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>H&#xF6;nigschmid</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Hopf</surname>
            <given-names>TA</given-names>
          </name>
          <name>
            <surname>Kaufmann</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Kiening</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Krompass</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Landerer</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Mahlich</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Roos</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Rost</surname>
            <given-names>B</given-names>
          </name>
          <article-title>Homology-based inference sets the bar high for protein function prediction</article-title>
          <source>BMC Bioinformatics</source>
          <year>2013</year>
          <volume>14</volume>
          <issue>Suppl 3</issue>
          <fpage>S7</fpage>
          <pub-id pub-id-type="doi">10.1186/1471-2105-14-S3-S7</pub-id>
          <pub-id pub-id-type="pmid">23514582</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B8">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Lovasz</surname>
            <given-names>L</given-names>
          </name>
          <article-title>Random walks on graphs: a survey</article-title>
          <source>Combinatorics, Paul Erdos is Eighty</source>
          <year>1993</year>
          <volume>2</volume>
          <fpage>1</fpage>
          <lpage>46</lpage>
        </mixed-citation>
      </ref>
      <ref id="B9">
        <mixed-citation publication-type="book">
          <name>
            <surname>Zhou</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Bousquet</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Lal</surname>
            <given-names>NT</given-names>
          </name>
          <name>
            <surname>Weston</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Sch&#xF6;lkopf</surname>
            <given-names>B</given-names>
          </name>
          <article-title>Learning with local and global consistency</article-title>
          <source>Advances in Neural Information Processing Systems 16</source>
          <year>2004</year>
          <publisher-name>Cambridge: MIT Press</publisher-name>
          <fpage>321</fpage>
          <lpage>328</lpage>
        </mixed-citation>
      </ref>
      <ref id="B10">
        <mixed-citation publication-type="book">
          <name>
            <surname>Bengio</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Delalleau</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Le Roux</surname>
            <given-names>N</given-names>
          </name>
          <person-group person-group-type="editor">Zien A, Sch&#xF6;lkopf B, Chapelle O</person-group>
          <article-title>Label propagation and quadratic Criterion</article-title>
          <source>Semi-Supervised Learning</source>
          <year>2006</year>
          <publisher-name>Cambridge: MIT Press</publisher-name>
          <fpage>193</fpage>
          <lpage>216</lpage>
        </mixed-citation>
      </ref>
      <ref id="B11">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Liu</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Chang</surname>
            <given-names>SF</given-names>
          </name>
          <article-title>Robust and scalable graph-based Semisupervised learning</article-title>
          <source>Proc IEEE</source>
          <year>2012</year>
          <volume>100</volume>
          <issue>9</issue>
          <fpage>2624</fpage>
          <lpage>2638</lpage>
        </mixed-citation>
      </ref>
      <ref id="B12">
        <mixed-citation publication-type="book">
          <name>
            <surname>Foster</surname>
            <given-names>J</given-names>
          </name>
          <source>Designing and Building Parallel Programs</source>
          <year>1995</year>
          <publisher-name>Boston: Addison Wesley</publisher-name>
        </mixed-citation>
      </ref>
      <ref id="B13">
        <mixed-citation publication-type="book">
          <name>
            <surname>Gonzalez</surname>
            <given-names>JE</given-names>
          </name>
          <name>
            <surname>Low</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Gu</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Bickson</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Guestrin</surname>
            <given-names>C</given-names>
          </name>
          <article-title>PowerGraph: Distributed graph-parallel computation on natural graphs</article-title>
          <source>OSDI&#x2019;12 Proceedings of the 10th USENIX conference on Operating Systems Design and Implementation</source>
          <year>2012</year>
          <publisher-name>Hollywood, CA: USENIX Association Berkeley</publisher-name>
          <fpage>17</fpage>
          <lpage>30</lpage>
        </mixed-citation>
      </ref>
      <ref id="B14">
        <mixed-citation publication-type="book">
          <name>
            <surname>Low</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Gonzalez</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Kyrola</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Bickson</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Guestrin</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Hellerstein</surname>
            <given-names>JM</given-names>
          </name>
          <article-title>GraphLab: a new parallel framework for machine learning</article-title>
          <source>Conference on Uncertainty in Artificial Intelligence (UAI)</source>
          <year>2010</year>
          <publisher-name>Catalina Island: AUAI Press</publisher-name>
        </mixed-citation>
      </ref>
      <ref id="B15">
        <mixed-citation publication-type="book">
          <name>
            <surname>Malewicz</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Austern</surname>
            <given-names>MH</given-names>
          </name>
          <name>
            <surname>Bik</surname>
            <given-names>AJC</given-names>
          </name>
          <name>
            <surname>Dehnert</surname>
            <given-names>JC</given-names>
          </name>
          <name>
            <surname>Horn</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Leiser</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Czajkowski</surname>
            <given-names>G</given-names>
          </name>
          <article-title>Pregel: a system for large-scale graph processing</article-title>
          <source>Proceedings of the ACM SIGMOD International Conference on Management of Data, SIGMOD 2010</source>
          <year>2010</year>
          <publisher-name>Indianapolis, Indiana, USA, New York: ACM Press</publisher-name>
          <fpage>135</fpage>
          <lpage>146</lpage>
        </mixed-citation>
      </ref>
      <ref id="B16">
        <mixed-citation publication-type="book">
          <name>
            <surname>Kyrola</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Blelloch</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Guestrin</surname>
            <given-names>C</given-names>
          </name>
          <article-title>GraphChi: large-scale graph computation on just a PC</article-title>
          <source>Proceedings of the 10th USENIX conference on Operating Systems Design and Implementation</source>
          <year>2012</year>
          <publisher-name>CA, USA: Hollywood, CA, USA, OSDI&#x2019;12: USENIX Association Berkeley</publisher-name>
          <fpage>31</fpage>
          <lpage>46</lpage>
        </mixed-citation>
      </ref>
      <ref id="B17">
        <mixed-citation publication-type="book">
          <name>
            <surname>Webber</surname>
            <given-names>J</given-names>
          </name>
          <article-title>A programmatic introduction to Neo4j</article-title>
          <source>Proceedings of the 3rd Annual Conference on Systems, Programming, and Applications: Software for Humanity</source>
          <year>2012</year>
          <publisher-name>Tucson: ACM</publisher-name>
          <fpage>217</fpage>
          <lpage>218</lpage>
        </mixed-citation>
      </ref>
      <ref id="B18">
        <mixed-citation publication-type="book">
          <name>
            <surname>Han</surname>
            <given-names>WS</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Park</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>JH</given-names>
          </name>
          <name>
            <surname>Kim</surname>
            <given-names>MS</given-names>
          </name>
          <name>
            <surname>Kim</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Yu</surname>
            <given-names>H</given-names>
          </name>
          <article-title>TurboGraph: a fast parallel graph engine handling billion-scale graphs in a single PC</article-title>
          <source>Proceedings of the 19th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</source>
          <year>2013</year>
          <publisher-name>New York: ACM</publisher-name>
          <fpage>77</fpage>
          <lpage>85</lpage>
        </mixed-citation>
      </ref>
      <ref id="B19">
        <mixed-citation publication-type="other">
          <name>
            <surname>Robinson</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Webber</surname>
            <given-names>J</given-names>
          </name>
          <source>Eifrem E: Graph Databases</source>
          <year>2013</year>
        </mixed-citation>
      </ref>
      <ref id="B20">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Karedla</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Love</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Wherry</surname>
            <given-names>B</given-names>
          </name>
          <article-title>Caching strategies to improve disk system performance</article-title>
          <source>Computer</source>
          <year>1994</year>
          <volume>27</volume>
          <fpage>38</fpage>
          <lpage>46</lpage>
        </mixed-citation>
      </ref>
      <ref id="B21">
        <mixed-citation publication-type="book">
          <name>
            <surname>Boldi</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Vigna</surname>
            <given-names>S</given-names>
          </name>
          <article-title>The WebGraph framework I: compression techniques</article-title>
          <source>In Proc. of the Thirteenth International World Wide Web Conference</source>
          <year>2003</year>
          <publisher-name>New York: ACM Press</publisher-name>
          <fpage>595</fpage>
          <lpage>601</lpage>
        </mixed-citation>
      </ref>
      <ref id="B22">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Have</surname>
            <given-names>C</given-names>
          </name>
          <article-title>Jensen L: Are graph databases ready for bioinformatics?</article-title>
          <source>Bioinformatics</source>
          <year>2013</year>
          <volume>29</volume>
          <issue>24</issue>
          <fpage>3107</fpage>
          <pub-id pub-id-type="doi">10.1093/bioinformatics/btt549</pub-id>
          <pub-id pub-id-type="pmid">24135261</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B23">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Mostafavi</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Ray</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Warde-Farley</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Grouios</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Morris</surname>
            <given-names>Q</given-names>
          </name>
          <article-title>GeneMANIA: a real-time multiple association network integration algorithm for predicting gene function</article-title>
          <source>Genome Biol</source>
          <year>2008</year>
          <volume>9</volume>
          <issue>S4</issue>
        </mixed-citation>
      </ref>
      <ref id="B24">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Kohler</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Bauer</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Horn</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Robinson</surname>
            <given-names>P</given-names>
          </name>
          <article-title>Walking the Interactome for prioritization of candiyear disease genes</article-title>
          <source>Am J Human Genet</source>
          <year>2008</year>
          <volume>82</volume>
          <issue>4</issue>
          <fpage>948</fpage>
          <lpage>958</lpage>
        </mixed-citation>
      </ref>
      <ref id="B25">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Re</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Mesiti</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Valentini</surname>
            <given-names>G</given-names>
          </name>
          <article-title>A fast ranking algorithm for predicting gene functions in biomolecular networks</article-title>
          <source>IEEE ACM Trans Comput Biol Bioinform</source>
          <year>2012</year>
          <volume>9</volume>
          <issue>6</issue>
          <fpage>1812</fpage>
          <lpage>1818</lpage>
        </mixed-citation>
      </ref>
      <ref id="B26">
        <mixed-citation publication-type="book">
          <name>
            <surname>Malewicz</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Austern</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Bik</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Dehnert</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Horn</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Leiser</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Czajkowski</surname>
            <given-names>G</given-names>
          </name>
          <article-title>Pregel: a system for large-scale graph processing</article-title>
          <source>Proceedings of the 2010 ACM SIGMOD International Conference on Management of Data, SIGMOD &#x2019;10</source>
          <year>2010</year>
          <publisher-name>Indianapolis, Indiana, USA. New York: ACM Press</publisher-name>
          <fpage>135</fpage>
          <lpage>146</lpage>
        </mixed-citation>
      </ref>
      <ref id="B27">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Ashburner</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Ball</surname>
            <given-names>CA</given-names>
          </name>
          <name>
            <surname>Blake</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>Botstein</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Butler</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Cherry</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Davis</surname>
            <given-names>AP</given-names>
          </name>
          <name>
            <surname>Dolinski</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Dwight</surname>
            <given-names>SS</given-names>
          </name>
          <name>
            <surname>Eppig</surname>
            <given-names>JT</given-names>
          </name>
          <name>
            <surname>Harris</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Hill</surname>
            <given-names>DP</given-names>
          </name>
          <name>
            <surname>Issel-Tarver</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Kasarskis</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Lewis</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Matese</surname>
            <given-names>JC</given-names>
          </name>
          <name>
            <surname>Richardson</surname>
            <given-names>JE</given-names>
          </name>
          <name>
            <surname>Ringwald</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Rubin</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Sherlock</surname>
            <given-names>G</given-names>
          </name>
          <article-title>Gene Ontology: tool for the unification of biology</article-title>
          <source>Nat Genet</source>
          <year>2000</year>
          <volume>25</volume>
          <fpage>25</fpage>
          <pub-id pub-id-type="doi">10.1038/75556</pub-id>
          <pub-id pub-id-type="pmid">10802651</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B28">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Angles</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Gutierrez</surname>
            <given-names>C</given-names>
          </name>
          <article-title>Survey of graph database models</article-title>
          <source>ACM Comput Surv</source>
          <year>2008</year>
          <volume>40</volume>
          <issue>1</issue>
          <fpage>Article 1</fpage>
        </mixed-citation>
      </ref>
      <ref id="B29">
        <mixed-citation publication-type="other">
          <name>
            <surname>Friedberg</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Linial</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Mooney</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Radivojac</surname>
            <given-names>P</given-names>
          </name>
          <article-title>Critical assessment of function annotation experiment</article-title>
          <year>2013</year>
          <comment>
            <ext-link ext-link-type="uri" xlink:href="http://biofunctionprediction.org">http://biofunctionprediction.org</ext-link>
          </comment>
        </mixed-citation>
      </ref>
      <ref id="B30">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Finn</surname>
            <given-names>RD</given-names>
          </name>
          <name>
            <surname>Mistry</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Schuster-B&#xF6;ckler</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Griffiths-Jones</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Hollich</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Lassmann</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Moxon</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Marshall</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Khanna</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Eddy</surname>
            <given-names>SR</given-names>
          </name>
          <name>
            <surname>Sonnhammer</surname>
            <given-names>ELL</given-names>
          </name>
          <name>
            <surname>Bateman</surname>
            <given-names>A</given-names>
          </name>
          <article-title>Pfam: clans, web tools and services</article-title>
          <source>Nucleic Acids Res</source>
          <year>2006</year>
          <volume>34</volume>
          <issue>suppl 1</issue>
          <fpage>D247&#x2014;D251</fpage>
          <pub-id pub-id-type="pmid">16381856</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B31">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Gough</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Karplus</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Hughey</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Chothia</surname>
            <given-names>C</given-names>
          </name>
          <article-title>Assignment of homology to genome sequences using a library of hidden Markov models that represent all proteins of known structure</article-title>
          <source>J Mol Biol</source>
          <year>2001</year>
          <volume>313</volume>
          <issue>4</issue>
          <fpage>903</fpage>
          <lpage>919</lpage>
          <pub-id pub-id-type="doi">10.1006/jmbi.2001.5080</pub-id>
          <pub-id pub-id-type="pmid">11697912</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B32">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Attwood</surname>
            <given-names>TK</given-names>
          </name>
          <name>
            <surname>Bradley</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Flower</surname>
            <given-names>DR</given-names>
          </name>
          <name>
            <surname>Gaulton</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Maudling</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Mitchell</surname>
            <given-names>AL</given-names>
          </name>
          <name>
            <surname>Moulton</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Nordle</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Paine</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Taylor</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Uddin</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Zygouri</surname>
            <given-names>C</given-names>
          </name>
          <article-title>PRINTS and its automatic supplement, prePRINTS</article-title>
          <source>Nucleic Acids Res</source>
          <year>2003</year>
          <volume>31</volume>
          <fpage>400</fpage>
          <lpage>402</lpage>
          <pub-id pub-id-type="doi">10.1093/nar/gkg030</pub-id>
          <pub-id pub-id-type="pmid">12520033</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B33">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Hulo</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Bairoch</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Bulliard</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Cerutti</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>De Castro</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Langendijk-Genevaux</surname>
            <given-names>PS</given-names>
          </name>
          <name>
            <surname>Pagni</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Sigrist</surname>
            <given-names>CJ</given-names>
          </name>
          <article-title>The PROSITE database</article-title>
          <source>Nucleic Acids Res</source>
          <year>2006</year>
          <volume>34</volume>
          <issue>suppl 1</issue>
          <fpage>D227&#x2014;D230</fpage>
          <pub-id pub-id-type="pmid">16381852</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B34">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Mulder</surname>
            <given-names>NJ</given-names>
          </name>
          <name>
            <surname>Apweiler</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Attwood</surname>
            <given-names>TK</given-names>
          </name>
          <name>
            <surname>Bairoch</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Bateman</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Binns</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Bork</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Buillard</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Cerutti</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Copley</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Courcelle</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Das</surname>
            <given-names>U</given-names>
          </name>
          <name>
            <surname>Daugherty</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Dibley</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Finn</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Fleischmann</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Gough</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Haft</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Hulo</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Hunter</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Kahn</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Kanapin</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Kejariwal</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Labarga</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Langendijk-Genevaux</surname>
            <given-names>PS</given-names>
          </name>
          <name>
            <surname>Lonsdale</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Lopez</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Letunic</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Madera</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Maslen</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
          <article-title>New developments in the InterPro database</article-title>
          <source>Nucleic Acids Res</source>
          <year>2007</year>
          <volume>35</volume>
          <issue>suppl 1</issue>
          <fpage>D224&#x2014;D228</fpage>
          <pub-id pub-id-type="pmid">17202162</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B35">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Muller</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Szklarczyk</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Julien</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Letunic</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Roth</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Kuhn</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Powell</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Von Mering</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Doerks</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Jensen</surname>
            <given-names>LJ</given-names>
          </name>
          <name>
            <surname>Bork</surname>
            <given-names>P</given-names>
          </name>
          <article-title>eggNOG v2. 0: extending the evolutionary genealogy of genes with enhanced non-supervised orthologous groups, species and functional annotations</article-title>
          <source>Nucleic Acids Res</source>
          <year>2010</year>
          <volume>38</volume>
          <issue>suppl 1</issue>
          <fpage>D190&#x2014;D195</fpage>
          <pub-id pub-id-type="pmid">19900971</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B36">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Letunic</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Copley</surname>
            <given-names>RR</given-names>
          </name>
          <name>
            <surname>Pils</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Pinkert</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Schultz</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Bork</surname>
            <given-names>P</given-names>
          </name>
          <article-title>SMART 5: domains in the context of genomes and networks</article-title>
          <source>Nucleic Acids Res</source>
          <year>2006</year>
          <volume>34</volume>
          <issue>suppl 1</issue>
          <fpage>D257&#x2014;D260</fpage>
          <pub-id pub-id-type="pmid">16381859</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B37">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Re</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Valentini</surname>
            <given-names>G</given-names>
          </name>
          <article-title>Network-based drug ranking and repositioning with respect to DrugBank therapeutic categories</article-title>
          <source>IEEE/ACM Trans Comput Biol Bioinform</source>
          <year>2013</year>
          <volume>10</volume>
          <issue>6</issue>
          <fpage>1359</fpage>
          <lpage>1371</lpage>
          <pub-id pub-id-type="pmid">24407295</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B38">
        <mixed-citation publication-type="other">
          <article-title>STRING database</article-title>
          <comment>
            <ext-link ext-link-type="uri" xlink:href="http://string-db.org">http://string-db.org</ext-link>
          </comment>
        </mixed-citation>
      </ref>
      <ref id="B39">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Franceschini</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Szklarczyk</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Frankild</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Kuhn</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Simonovic</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Roth</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Lin</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Minguez</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Bork</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Von Mering</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Jensen</surname>
            <given-names>LJ</given-names>
          </name>
          <article-title>STRING v9. 1: protein-protein interaction networks, with increased coverage and integration</article-title>
          <source>Nucleic Acids Res</source>
          <year>2013</year>
          <volume>41</volume>
          <issue>D1</issue>
          <fpage>D808&#x2014;D815</fpage>
          <pub-id pub-id-type="pmid">23203871</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B40">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Von Mering</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Jensen</surname>
            <given-names>LJ</given-names>
          </name>
          <name>
            <surname>Kuhn</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Chaffron</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Doerks</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Kr&#xFC;ger</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Snel</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Bork</surname>
            <given-names>P</given-names>
          </name>
          <article-title>STRING 7 recent developments in the integration and prediction of protein interactions</article-title>
          <source>Nucleic Acids Res</source>
          <year>2007</year>
          <volume>35</volume>
          <issue>suppl 1</issue>
          <fpage>D358&#x2014;D362</fpage>
          <pub-id pub-id-type="pmid">17098935</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B41">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Marcotte</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Pellegrini</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Thompson</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Yeates</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Eisenberg</surname>
            <given-names>D</given-names>
          </name>
          <article-title>A combined algorithm for genome-wide prediction of protein function</article-title>
          <source>Nature</source>
          <year>1999</year>
          <volume>402</volume>
          <fpage>83</fpage>
          <lpage>86</lpage>
          <pub-id pub-id-type="doi">10.1038/47048</pub-id>
          <pub-id pub-id-type="pmid">10573421</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B42">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Bumgarner</surname>
            <given-names>McDermottRJand</given-names>
          </name>
          <name>
            <surname>Samudrala</surname>
            <given-names>R</given-names>
          </name>
          <article-title>Functional annotation from predicted protein interaction networks</article-title>
          <source>Bioinformatics</source>
          <year>2005</year>
          <volume>21</volume>
          <issue>15</issue>
          <fpage>3217</fpage>
          <lpage>3226</lpage>
          <pub-id pub-id-type="doi">10.1093/bioinformatics/bti514</pub-id>
          <pub-id pub-id-type="pmid">15919725</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B43">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Lippert</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Ghahramani</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Borgwardt</surname>
            <given-names>K</given-names>
          </name>
          <article-title>Gene function prediction form synthetic leathality networks via ranking on demand</article-title>
          <source>Bioinformatics</source>
          <year>2010</year>
          <volume>26</volume>
          <issue>7</issue>
          <fpage>912</fpage>
          <lpage>918</lpage>
          <pub-id pub-id-type="doi">10.1093/bioinformatics/btq053</pub-id>
          <pub-id pub-id-type="pmid">20154010</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B44">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Re</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Valentini</surname>
            <given-names>G</given-names>
          </name>
          <article-title>Cancer module genes ranking using kernelized score functions</article-title>
          <source>BMC Bioinformatics</source>
          <year>2012</year>
          <volume>13</volume>
          <issue>S14</issue>
          <fpage>S3</fpage>
          <pub-id pub-id-type="pmid">23095178</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B45">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Frasca</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Bertoni</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Re</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Valentini</surname>
            <given-names>G</given-names>
          </name>
          <article-title>A neural network algorithm for semi-supervised node label learning from unbalanced data</article-title>
          <source>Neural Netw</source>
          <year>2013</year>
          <volume>43</volume>
          <fpage>84</fpage>
          <lpage>98</lpage>
          <pub-id pub-id-type="pmid">23500503</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B46">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Barabasi</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Gulbahce</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Loscalzo</surname>
            <given-names>J</given-names>
          </name>
          <article-title>Network medicine: a network-based approach to human disease</article-title>
          <source>Nat Rev Genet</source>
          <year>2011</year>
          <volume>12</volume>
          <fpage>56</fpage>
          <lpage>68</lpage>
          <pub-id pub-id-type="doi">10.1038/nrg2918</pub-id>
          <pub-id pub-id-type="pmid">21164525</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B47">
        <mixed-citation publication-type="journal">
          <name>
            <surname>Dudley</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Desphonde</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Butte</surname>
            <given-names>A</given-names>
          </name>
          <article-title>Exploiting Drug-disease relationships for computational drug repositioning</article-title>
          <source>Brief Bioinform</source>
          <year>2011</year>
          <volume>12</volume>
          <issue>4</issue>
          <fpage>303</fpage>
          <lpage>311</lpage>
          <pub-id pub-id-type="doi">10.1093/bib/bbr013</pub-id>
          <pub-id pub-id-type="pmid">21690101</pub-id>
        </mixed-citation>
      </ref>
      <ref id="B48">
        <mixed-citation publication-type="other">
          <name>
            <surname>Mesiti</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Re</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Valentini</surname>
            <given-names>G</given-names>
          </name>
          <article-title>Supporting materials from &#x2018;Think globally and solve locally: secondary memory-based network learning for automated multi-species function prediction&#x2019; GigaScience Database</article-title>
          <year>2014</year>
          <comment>
            <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.5524/100090">http://dx.doi.org/10.5524/100090</ext-link>
          </comment>
        </mixed-citation>
      </ref>
    </ref-list>
  </back>
</article>
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article">
  <!--The publisher of this article does not allow downloading of the full text in XML form.-->
  <?properties manuscript?>
  <front>
    <journal-meta>
      <journal-id journal-id-type="nlm-journal-id">9607483</journal-id>
      <journal-id journal-id-type="pubmed-jr-id">22834</journal-id>
      <journal-id journal-id-type="nlm-ta">Adv Neural Inf Process Syst</journal-id>
      <journal-id journal-id-type="iso-abbrev">Adv Neural Inf Process Syst</journal-id>
      <journal-title-group>
        <journal-title>Advances in neural information processing systems</journal-title>
      </journal-title-group>
      <issn pub-type="ppub">1049-5258</issn>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="pmid">25400488</article-id>
      <article-id pub-id-type="pmc">4230489</article-id>
      <article-id pub-id-type="manuscript">NIHMS577698</article-id>
      <article-categories>
        <subj-group subj-group-type="heading">
          <subject>Article</subject>
        </subj-group>
      </article-categories>
      <title-group>
        <article-title>More Effective Distributed ML via a Stale Synchronous Parallel Parameter Server</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author">
          <name>
            <surname>Ho</surname>
            <given-names>Qirong</given-names>
          </name>
          <xref ref-type="aff" rid="A1">&#x2020;</xref>
          <email>qho@cs.cmu.edu</email>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Cipar</surname>
            <given-names>James</given-names>
          </name>
          <xref ref-type="aff" rid="A1">&#x2020;</xref>
          <email>jcipar@cs.cmu.edu</email>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Cui</surname>
            <given-names>Henggang</given-names>
          </name>
          <xref ref-type="aff" rid="A2">&#xA7;</xref>
          <email>hengganc@ece.cmu.edu</email>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Kim</surname>
            <given-names>Jin Kyu</given-names>
          </name>
          <xref ref-type="aff" rid="A1">&#x2020;</xref>
          <email>jinkyuk@cs.cmu.edu</email>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Lee</surname>
            <given-names>Seunghak</given-names>
          </name>
          <xref ref-type="aff" rid="A1">&#x2020;</xref>
          <email>seunghak@cs.cmu.edu</email>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Gibbons</surname>
            <given-names>Phillip B.</given-names>
          </name>
          <xref ref-type="aff" rid="A3">&#x2021;</xref>
          <email>phillip.b.gibbons@intel.com</email>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Gibson</surname>
            <given-names>Garth A.</given-names>
          </name>
          <xref ref-type="aff" rid="A1">&#x2020;</xref>
          <email>garth@cs.cmu.edu</email>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Ganger</surname>
            <given-names>Gregory R.</given-names>
          </name>
          <xref ref-type="aff" rid="A2">&#xA7;</xref>
          <email>ganger@ece.cmu.edu</email>
        </contrib>
        <contrib contrib-type="author">
          <name>
            <surname>Xing</surname>
            <given-names>Eric P.</given-names>
          </name>
          <xref ref-type="aff" rid="A1">&#x2020;</xref>
          <email>epxing@cs.cmu.edu</email>
        </contrib>
      </contrib-group>
      <aff id="A1"><label>&#x2020;</label>School of Computer Science, Carnegie Mellon University, Pittsburgh, PA 15213</aff>
      <aff id="A2"><label>&#xA7;</label>Electrical and Computer Engineering, Carnegie Mellon University, Pittsburgh, PA 15213</aff>
      <aff id="A3"><label>&#x2021;</label>Intel Labs, Pittsburgh, PA 15213</aff>
      <pub-date pub-type="nihms-submitted">
        <day>7</day>
        <month>5</month>
        <year>2014</year>
      </pub-date>
      <pub-date pub-type="ppub">
        <year>2013</year>
      </pub-date>
      <pub-date pub-type="pmc-release">
        <day>13</day>
        <month>11</month>
        <year>2014</year>
      </pub-date>
      <volume>2013</volume>
      <fpage>1223</fpage>
      <lpage>1231</lpage>
      <abstract>
        <p id="P1">We propose a parameter server system for distributed ML, which follows a Stale Synchronous Parallel (SSP) model of computation that maximizes the time computational workers spend doing useful work on ML algorithms, while still providing correctness guarantees. The parameter server provides an easy-to-use shared interface for read/write access to an ML model&#x2019;s values (parameters and variables), and the SSP model allows distributed workers to read older, stale versions of these values from a local cache, instead of waiting to get them from a central storage. This significantly increases the proportion of time workers spend computing, as opposed to waiting. Furthermore, the SSP model ensures ML algorithm correctness by limiting the maximum age of the stale values. We provide a proof of correctness under SSP, as well as empirical results demonstrating that the SSP model achieves faster algorithm convergence on several different ML problems, compared to fully-synchronous and asynchronous schemes.</p>
      </abstract>
    </article-meta>
  </front>
</article>
</pmc-articleset>
